// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

import (
	"context"
	"fmt"
	"reflect"

	"github.com/mark-ahn/syncs"
)

func OfBytesClear(ch <-chan Bytes) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfBytesBroadCaster struct {
	srcs        map[<-chan Bytes]struct{}
	recvs       map[chan<- Bytes]struct{}
	add_src     chan (<-chan Bytes)
	delete_src  chan (<-chan Bytes)
	add_recv    chan (chan<- Bytes)
	delete_recv chan (chan<- Bytes)
}

func NewOfBytesBroadCaster(initSrcs []<-chan Bytes, initRecvs []chan<- Bytes) *OfBytesBroadCaster {
	// fmt.Println("NewOfBytesBroadCaster")
	srcs := make(map[<-chan Bytes]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- Bytes]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfBytesBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan Bytes)),
		delete_src:  make(chan (<-chan Bytes)),
		add_recv:    make(chan (chan<- Bytes)),
		delete_recv: make(chan (chan<- Bytes)),
	}
}

func (__ *OfBytesBroadCaster) AddSources(srcs ...<-chan Bytes) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfBytesBroadCaster) DeleteSources(srcs ...<-chan Bytes) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfBytesBroadCaster) AddReceivers(recvs ...chan<- Bytes) *OfBytesBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfBytesBroadCaster) DeleteReceivers(recvs ...chan<- Bytes) *OfBytesBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfBytesBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfBytesBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan Bytes){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- Bytes){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfBytesBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan Bytes:
				d := recv.Interface().(Bytes)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan Bytes):
				d := recv.Interface().(<-chan Bytes)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- Bytes):
				d := recv.Interface().(chan<- Bytes)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfBoolClear(ch <-chan bool) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfBoolBroadCaster struct {
	srcs        map[<-chan bool]struct{}
	recvs       map[chan<- bool]struct{}
	add_src     chan (<-chan bool)
	delete_src  chan (<-chan bool)
	add_recv    chan (chan<- bool)
	delete_recv chan (chan<- bool)
}

func NewOfBoolBroadCaster(initSrcs []<-chan bool, initRecvs []chan<- bool) *OfBoolBroadCaster {
	// fmt.Println("NewOfBoolBroadCaster")
	srcs := make(map[<-chan bool]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- bool]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfBoolBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan bool)),
		delete_src:  make(chan (<-chan bool)),
		add_recv:    make(chan (chan<- bool)),
		delete_recv: make(chan (chan<- bool)),
	}
}

func (__ *OfBoolBroadCaster) AddSources(srcs ...<-chan bool) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfBoolBroadCaster) DeleteSources(srcs ...<-chan bool) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfBoolBroadCaster) AddReceivers(recvs ...chan<- bool) *OfBoolBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfBoolBroadCaster) DeleteReceivers(recvs ...chan<- bool) *OfBoolBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfBoolBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfBoolBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan bool){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- bool){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfBoolBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan bool:
				d := recv.Interface().(bool)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan bool):
				d := recv.Interface().(<-chan bool)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- bool):
				d := recv.Interface().(chan<- bool)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfByteClear(ch <-chan byte) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfByteBroadCaster struct {
	srcs        map[<-chan byte]struct{}
	recvs       map[chan<- byte]struct{}
	add_src     chan (<-chan byte)
	delete_src  chan (<-chan byte)
	add_recv    chan (chan<- byte)
	delete_recv chan (chan<- byte)
}

func NewOfByteBroadCaster(initSrcs []<-chan byte, initRecvs []chan<- byte) *OfByteBroadCaster {
	// fmt.Println("NewOfByteBroadCaster")
	srcs := make(map[<-chan byte]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- byte]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfByteBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan byte)),
		delete_src:  make(chan (<-chan byte)),
		add_recv:    make(chan (chan<- byte)),
		delete_recv: make(chan (chan<- byte)),
	}
}

func (__ *OfByteBroadCaster) AddSources(srcs ...<-chan byte) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfByteBroadCaster) DeleteSources(srcs ...<-chan byte) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfByteBroadCaster) AddReceivers(recvs ...chan<- byte) *OfByteBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfByteBroadCaster) DeleteReceivers(recvs ...chan<- byte) *OfByteBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfByteBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfByteBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan byte){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- byte){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfByteBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan byte:
				d := recv.Interface().(byte)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan byte):
				d := recv.Interface().(<-chan byte)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- byte):
				d := recv.Interface().(chan<- byte)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfComplex128Clear(ch <-chan complex128) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfComplex128BroadCaster struct {
	srcs        map[<-chan complex128]struct{}
	recvs       map[chan<- complex128]struct{}
	add_src     chan (<-chan complex128)
	delete_src  chan (<-chan complex128)
	add_recv    chan (chan<- complex128)
	delete_recv chan (chan<- complex128)
}

func NewOfComplex128BroadCaster(initSrcs []<-chan complex128, initRecvs []chan<- complex128) *OfComplex128BroadCaster {
	// fmt.Println("NewOfComplex128BroadCaster")
	srcs := make(map[<-chan complex128]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- complex128]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfComplex128BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan complex128)),
		delete_src:  make(chan (<-chan complex128)),
		add_recv:    make(chan (chan<- complex128)),
		delete_recv: make(chan (chan<- complex128)),
	}
}

func (__ *OfComplex128BroadCaster) AddSources(srcs ...<-chan complex128) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfComplex128BroadCaster) DeleteSources(srcs ...<-chan complex128) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfComplex128BroadCaster) AddReceivers(recvs ...chan<- complex128) *OfComplex128BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfComplex128BroadCaster) DeleteReceivers(recvs ...chan<- complex128) *OfComplex128BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfComplex128BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfComplex128BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan complex128){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- complex128){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfComplex128BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan complex128:
				d := recv.Interface().(complex128)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan complex128):
				d := recv.Interface().(<-chan complex128)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- complex128):
				d := recv.Interface().(chan<- complex128)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfComplex64Clear(ch <-chan complex64) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfComplex64BroadCaster struct {
	srcs        map[<-chan complex64]struct{}
	recvs       map[chan<- complex64]struct{}
	add_src     chan (<-chan complex64)
	delete_src  chan (<-chan complex64)
	add_recv    chan (chan<- complex64)
	delete_recv chan (chan<- complex64)
}

func NewOfComplex64BroadCaster(initSrcs []<-chan complex64, initRecvs []chan<- complex64) *OfComplex64BroadCaster {
	// fmt.Println("NewOfComplex64BroadCaster")
	srcs := make(map[<-chan complex64]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- complex64]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfComplex64BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan complex64)),
		delete_src:  make(chan (<-chan complex64)),
		add_recv:    make(chan (chan<- complex64)),
		delete_recv: make(chan (chan<- complex64)),
	}
}

func (__ *OfComplex64BroadCaster) AddSources(srcs ...<-chan complex64) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfComplex64BroadCaster) DeleteSources(srcs ...<-chan complex64) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfComplex64BroadCaster) AddReceivers(recvs ...chan<- complex64) *OfComplex64BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfComplex64BroadCaster) DeleteReceivers(recvs ...chan<- complex64) *OfComplex64BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfComplex64BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfComplex64BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan complex64){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- complex64){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfComplex64BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan complex64:
				d := recv.Interface().(complex64)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan complex64):
				d := recv.Interface().(<-chan complex64)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- complex64):
				d := recv.Interface().(chan<- complex64)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfErrorClear(ch <-chan error) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfErrorBroadCaster struct {
	srcs        map[<-chan error]struct{}
	recvs       map[chan<- error]struct{}
	add_src     chan (<-chan error)
	delete_src  chan (<-chan error)
	add_recv    chan (chan<- error)
	delete_recv chan (chan<- error)
}

func NewOfErrorBroadCaster(initSrcs []<-chan error, initRecvs []chan<- error) *OfErrorBroadCaster {
	// fmt.Println("NewOfErrorBroadCaster")
	srcs := make(map[<-chan error]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- error]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfErrorBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan error)),
		delete_src:  make(chan (<-chan error)),
		add_recv:    make(chan (chan<- error)),
		delete_recv: make(chan (chan<- error)),
	}
}

func (__ *OfErrorBroadCaster) AddSources(srcs ...<-chan error) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfErrorBroadCaster) DeleteSources(srcs ...<-chan error) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfErrorBroadCaster) AddReceivers(recvs ...chan<- error) *OfErrorBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfErrorBroadCaster) DeleteReceivers(recvs ...chan<- error) *OfErrorBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfErrorBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfErrorBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan error){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- error){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfErrorBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan error:
				d := recv.Interface().(error)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan error):
				d := recv.Interface().(<-chan error)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- error):
				d := recv.Interface().(chan<- error)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfFloat32Clear(ch <-chan float32) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfFloat32BroadCaster struct {
	srcs        map[<-chan float32]struct{}
	recvs       map[chan<- float32]struct{}
	add_src     chan (<-chan float32)
	delete_src  chan (<-chan float32)
	add_recv    chan (chan<- float32)
	delete_recv chan (chan<- float32)
}

func NewOfFloat32BroadCaster(initSrcs []<-chan float32, initRecvs []chan<- float32) *OfFloat32BroadCaster {
	// fmt.Println("NewOfFloat32BroadCaster")
	srcs := make(map[<-chan float32]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- float32]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfFloat32BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan float32)),
		delete_src:  make(chan (<-chan float32)),
		add_recv:    make(chan (chan<- float32)),
		delete_recv: make(chan (chan<- float32)),
	}
}

func (__ *OfFloat32BroadCaster) AddSources(srcs ...<-chan float32) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfFloat32BroadCaster) DeleteSources(srcs ...<-chan float32) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfFloat32BroadCaster) AddReceivers(recvs ...chan<- float32) *OfFloat32BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfFloat32BroadCaster) DeleteReceivers(recvs ...chan<- float32) *OfFloat32BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfFloat32BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfFloat32BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan float32){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- float32){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfFloat32BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan float32:
				d := recv.Interface().(float32)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan float32):
				d := recv.Interface().(<-chan float32)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- float32):
				d := recv.Interface().(chan<- float32)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfFloat64Clear(ch <-chan float64) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfFloat64BroadCaster struct {
	srcs        map[<-chan float64]struct{}
	recvs       map[chan<- float64]struct{}
	add_src     chan (<-chan float64)
	delete_src  chan (<-chan float64)
	add_recv    chan (chan<- float64)
	delete_recv chan (chan<- float64)
}

func NewOfFloat64BroadCaster(initSrcs []<-chan float64, initRecvs []chan<- float64) *OfFloat64BroadCaster {
	// fmt.Println("NewOfFloat64BroadCaster")
	srcs := make(map[<-chan float64]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- float64]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfFloat64BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan float64)),
		delete_src:  make(chan (<-chan float64)),
		add_recv:    make(chan (chan<- float64)),
		delete_recv: make(chan (chan<- float64)),
	}
}

func (__ *OfFloat64BroadCaster) AddSources(srcs ...<-chan float64) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfFloat64BroadCaster) DeleteSources(srcs ...<-chan float64) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfFloat64BroadCaster) AddReceivers(recvs ...chan<- float64) *OfFloat64BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfFloat64BroadCaster) DeleteReceivers(recvs ...chan<- float64) *OfFloat64BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfFloat64BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfFloat64BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan float64){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- float64){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfFloat64BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan float64:
				d := recv.Interface().(float64)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan float64):
				d := recv.Interface().(<-chan float64)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- float64):
				d := recv.Interface().(chan<- float64)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfIntClear(ch <-chan int) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfIntBroadCaster struct {
	srcs        map[<-chan int]struct{}
	recvs       map[chan<- int]struct{}
	add_src     chan (<-chan int)
	delete_src  chan (<-chan int)
	add_recv    chan (chan<- int)
	delete_recv chan (chan<- int)
}

func NewOfIntBroadCaster(initSrcs []<-chan int, initRecvs []chan<- int) *OfIntBroadCaster {
	// fmt.Println("NewOfIntBroadCaster")
	srcs := make(map[<-chan int]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- int]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfIntBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan int)),
		delete_src:  make(chan (<-chan int)),
		add_recv:    make(chan (chan<- int)),
		delete_recv: make(chan (chan<- int)),
	}
}

func (__ *OfIntBroadCaster) AddSources(srcs ...<-chan int) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfIntBroadCaster) DeleteSources(srcs ...<-chan int) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfIntBroadCaster) AddReceivers(recvs ...chan<- int) *OfIntBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfIntBroadCaster) DeleteReceivers(recvs ...chan<- int) *OfIntBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfIntBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfIntBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan int){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- int){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfIntBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan int:
				d := recv.Interface().(int)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan int):
				d := recv.Interface().(<-chan int)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- int):
				d := recv.Interface().(chan<- int)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfInt16Clear(ch <-chan int16) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInt16BroadCaster struct {
	srcs        map[<-chan int16]struct{}
	recvs       map[chan<- int16]struct{}
	add_src     chan (<-chan int16)
	delete_src  chan (<-chan int16)
	add_recv    chan (chan<- int16)
	delete_recv chan (chan<- int16)
}

func NewOfInt16BroadCaster(initSrcs []<-chan int16, initRecvs []chan<- int16) *OfInt16BroadCaster {
	// fmt.Println("NewOfInt16BroadCaster")
	srcs := make(map[<-chan int16]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- int16]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfInt16BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan int16)),
		delete_src:  make(chan (<-chan int16)),
		add_recv:    make(chan (chan<- int16)),
		delete_recv: make(chan (chan<- int16)),
	}
}

func (__ *OfInt16BroadCaster) AddSources(srcs ...<-chan int16) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfInt16BroadCaster) DeleteSources(srcs ...<-chan int16) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfInt16BroadCaster) AddReceivers(recvs ...chan<- int16) *OfInt16BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfInt16BroadCaster) DeleteReceivers(recvs ...chan<- int16) *OfInt16BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfInt16BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfInt16BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan int16){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- int16){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfInt16BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan int16:
				d := recv.Interface().(int16)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan int16):
				d := recv.Interface().(<-chan int16)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- int16):
				d := recv.Interface().(chan<- int16)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfInt32Clear(ch <-chan int32) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInt32BroadCaster struct {
	srcs        map[<-chan int32]struct{}
	recvs       map[chan<- int32]struct{}
	add_src     chan (<-chan int32)
	delete_src  chan (<-chan int32)
	add_recv    chan (chan<- int32)
	delete_recv chan (chan<- int32)
}

func NewOfInt32BroadCaster(initSrcs []<-chan int32, initRecvs []chan<- int32) *OfInt32BroadCaster {
	// fmt.Println("NewOfInt32BroadCaster")
	srcs := make(map[<-chan int32]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- int32]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfInt32BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan int32)),
		delete_src:  make(chan (<-chan int32)),
		add_recv:    make(chan (chan<- int32)),
		delete_recv: make(chan (chan<- int32)),
	}
}

func (__ *OfInt32BroadCaster) AddSources(srcs ...<-chan int32) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfInt32BroadCaster) DeleteSources(srcs ...<-chan int32) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfInt32BroadCaster) AddReceivers(recvs ...chan<- int32) *OfInt32BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfInt32BroadCaster) DeleteReceivers(recvs ...chan<- int32) *OfInt32BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfInt32BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfInt32BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan int32){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- int32){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfInt32BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan int32:
				d := recv.Interface().(int32)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan int32):
				d := recv.Interface().(<-chan int32)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- int32):
				d := recv.Interface().(chan<- int32)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfInt64Clear(ch <-chan int64) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInt64BroadCaster struct {
	srcs        map[<-chan int64]struct{}
	recvs       map[chan<- int64]struct{}
	add_src     chan (<-chan int64)
	delete_src  chan (<-chan int64)
	add_recv    chan (chan<- int64)
	delete_recv chan (chan<- int64)
}

func NewOfInt64BroadCaster(initSrcs []<-chan int64, initRecvs []chan<- int64) *OfInt64BroadCaster {
	// fmt.Println("NewOfInt64BroadCaster")
	srcs := make(map[<-chan int64]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- int64]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfInt64BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan int64)),
		delete_src:  make(chan (<-chan int64)),
		add_recv:    make(chan (chan<- int64)),
		delete_recv: make(chan (chan<- int64)),
	}
}

func (__ *OfInt64BroadCaster) AddSources(srcs ...<-chan int64) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfInt64BroadCaster) DeleteSources(srcs ...<-chan int64) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfInt64BroadCaster) AddReceivers(recvs ...chan<- int64) *OfInt64BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfInt64BroadCaster) DeleteReceivers(recvs ...chan<- int64) *OfInt64BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfInt64BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfInt64BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan int64){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- int64){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfInt64BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan int64:
				d := recv.Interface().(int64)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan int64):
				d := recv.Interface().(<-chan int64)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- int64):
				d := recv.Interface().(chan<- int64)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfInt8Clear(ch <-chan int8) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInt8BroadCaster struct {
	srcs        map[<-chan int8]struct{}
	recvs       map[chan<- int8]struct{}
	add_src     chan (<-chan int8)
	delete_src  chan (<-chan int8)
	add_recv    chan (chan<- int8)
	delete_recv chan (chan<- int8)
}

func NewOfInt8BroadCaster(initSrcs []<-chan int8, initRecvs []chan<- int8) *OfInt8BroadCaster {
	// fmt.Println("NewOfInt8BroadCaster")
	srcs := make(map[<-chan int8]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- int8]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfInt8BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan int8)),
		delete_src:  make(chan (<-chan int8)),
		add_recv:    make(chan (chan<- int8)),
		delete_recv: make(chan (chan<- int8)),
	}
}

func (__ *OfInt8BroadCaster) AddSources(srcs ...<-chan int8) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfInt8BroadCaster) DeleteSources(srcs ...<-chan int8) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfInt8BroadCaster) AddReceivers(recvs ...chan<- int8) *OfInt8BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfInt8BroadCaster) DeleteReceivers(recvs ...chan<- int8) *OfInt8BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfInt8BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfInt8BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan int8){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- int8){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfInt8BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan int8:
				d := recv.Interface().(int8)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan int8):
				d := recv.Interface().(<-chan int8)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- int8):
				d := recv.Interface().(chan<- int8)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfRuneClear(ch <-chan rune) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfRuneBroadCaster struct {
	srcs        map[<-chan rune]struct{}
	recvs       map[chan<- rune]struct{}
	add_src     chan (<-chan rune)
	delete_src  chan (<-chan rune)
	add_recv    chan (chan<- rune)
	delete_recv chan (chan<- rune)
}

func NewOfRuneBroadCaster(initSrcs []<-chan rune, initRecvs []chan<- rune) *OfRuneBroadCaster {
	// fmt.Println("NewOfRuneBroadCaster")
	srcs := make(map[<-chan rune]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- rune]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfRuneBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan rune)),
		delete_src:  make(chan (<-chan rune)),
		add_recv:    make(chan (chan<- rune)),
		delete_recv: make(chan (chan<- rune)),
	}
}

func (__ *OfRuneBroadCaster) AddSources(srcs ...<-chan rune) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfRuneBroadCaster) DeleteSources(srcs ...<-chan rune) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfRuneBroadCaster) AddReceivers(recvs ...chan<- rune) *OfRuneBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfRuneBroadCaster) DeleteReceivers(recvs ...chan<- rune) *OfRuneBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfRuneBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfRuneBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan rune){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- rune){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfRuneBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan rune:
				d := recv.Interface().(rune)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan rune):
				d := recv.Interface().(<-chan rune)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- rune):
				d := recv.Interface().(chan<- rune)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfStringClear(ch <-chan string) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfStringBroadCaster struct {
	srcs        map[<-chan string]struct{}
	recvs       map[chan<- string]struct{}
	add_src     chan (<-chan string)
	delete_src  chan (<-chan string)
	add_recv    chan (chan<- string)
	delete_recv chan (chan<- string)
}

func NewOfStringBroadCaster(initSrcs []<-chan string, initRecvs []chan<- string) *OfStringBroadCaster {
	// fmt.Println("NewOfStringBroadCaster")
	srcs := make(map[<-chan string]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- string]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfStringBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan string)),
		delete_src:  make(chan (<-chan string)),
		add_recv:    make(chan (chan<- string)),
		delete_recv: make(chan (chan<- string)),
	}
}

func (__ *OfStringBroadCaster) AddSources(srcs ...<-chan string) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfStringBroadCaster) DeleteSources(srcs ...<-chan string) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfStringBroadCaster) AddReceivers(recvs ...chan<- string) *OfStringBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfStringBroadCaster) DeleteReceivers(recvs ...chan<- string) *OfStringBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfStringBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfStringBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan string){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- string){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfStringBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan string:
				d := recv.Interface().(string)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan string):
				d := recv.Interface().(<-chan string)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- string):
				d := recv.Interface().(chan<- string)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfUintClear(ch <-chan uint) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUintBroadCaster struct {
	srcs        map[<-chan uint]struct{}
	recvs       map[chan<- uint]struct{}
	add_src     chan (<-chan uint)
	delete_src  chan (<-chan uint)
	add_recv    chan (chan<- uint)
	delete_recv chan (chan<- uint)
}

func NewOfUintBroadCaster(initSrcs []<-chan uint, initRecvs []chan<- uint) *OfUintBroadCaster {
	// fmt.Println("NewOfUintBroadCaster")
	srcs := make(map[<-chan uint]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- uint]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfUintBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan uint)),
		delete_src:  make(chan (<-chan uint)),
		add_recv:    make(chan (chan<- uint)),
		delete_recv: make(chan (chan<- uint)),
	}
}

func (__ *OfUintBroadCaster) AddSources(srcs ...<-chan uint) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfUintBroadCaster) DeleteSources(srcs ...<-chan uint) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfUintBroadCaster) AddReceivers(recvs ...chan<- uint) *OfUintBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfUintBroadCaster) DeleteReceivers(recvs ...chan<- uint) *OfUintBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfUintBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfUintBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan uint){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- uint){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfUintBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan uint:
				d := recv.Interface().(uint)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan uint):
				d := recv.Interface().(<-chan uint)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- uint):
				d := recv.Interface().(chan<- uint)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfUint16Clear(ch <-chan uint16) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUint16BroadCaster struct {
	srcs        map[<-chan uint16]struct{}
	recvs       map[chan<- uint16]struct{}
	add_src     chan (<-chan uint16)
	delete_src  chan (<-chan uint16)
	add_recv    chan (chan<- uint16)
	delete_recv chan (chan<- uint16)
}

func NewOfUint16BroadCaster(initSrcs []<-chan uint16, initRecvs []chan<- uint16) *OfUint16BroadCaster {
	// fmt.Println("NewOfUint16BroadCaster")
	srcs := make(map[<-chan uint16]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- uint16]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfUint16BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan uint16)),
		delete_src:  make(chan (<-chan uint16)),
		add_recv:    make(chan (chan<- uint16)),
		delete_recv: make(chan (chan<- uint16)),
	}
}

func (__ *OfUint16BroadCaster) AddSources(srcs ...<-chan uint16) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfUint16BroadCaster) DeleteSources(srcs ...<-chan uint16) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfUint16BroadCaster) AddReceivers(recvs ...chan<- uint16) *OfUint16BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfUint16BroadCaster) DeleteReceivers(recvs ...chan<- uint16) *OfUint16BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfUint16BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfUint16BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan uint16){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- uint16){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfUint16BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan uint16:
				d := recv.Interface().(uint16)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan uint16):
				d := recv.Interface().(<-chan uint16)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- uint16):
				d := recv.Interface().(chan<- uint16)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfUint32Clear(ch <-chan uint32) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUint32BroadCaster struct {
	srcs        map[<-chan uint32]struct{}
	recvs       map[chan<- uint32]struct{}
	add_src     chan (<-chan uint32)
	delete_src  chan (<-chan uint32)
	add_recv    chan (chan<- uint32)
	delete_recv chan (chan<- uint32)
}

func NewOfUint32BroadCaster(initSrcs []<-chan uint32, initRecvs []chan<- uint32) *OfUint32BroadCaster {
	// fmt.Println("NewOfUint32BroadCaster")
	srcs := make(map[<-chan uint32]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- uint32]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfUint32BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan uint32)),
		delete_src:  make(chan (<-chan uint32)),
		add_recv:    make(chan (chan<- uint32)),
		delete_recv: make(chan (chan<- uint32)),
	}
}

func (__ *OfUint32BroadCaster) AddSources(srcs ...<-chan uint32) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfUint32BroadCaster) DeleteSources(srcs ...<-chan uint32) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfUint32BroadCaster) AddReceivers(recvs ...chan<- uint32) *OfUint32BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfUint32BroadCaster) DeleteReceivers(recvs ...chan<- uint32) *OfUint32BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfUint32BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfUint32BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan uint32){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- uint32){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfUint32BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan uint32:
				d := recv.Interface().(uint32)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan uint32):
				d := recv.Interface().(<-chan uint32)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- uint32):
				d := recv.Interface().(chan<- uint32)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfUint64Clear(ch <-chan uint64) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUint64BroadCaster struct {
	srcs        map[<-chan uint64]struct{}
	recvs       map[chan<- uint64]struct{}
	add_src     chan (<-chan uint64)
	delete_src  chan (<-chan uint64)
	add_recv    chan (chan<- uint64)
	delete_recv chan (chan<- uint64)
}

func NewOfUint64BroadCaster(initSrcs []<-chan uint64, initRecvs []chan<- uint64) *OfUint64BroadCaster {
	// fmt.Println("NewOfUint64BroadCaster")
	srcs := make(map[<-chan uint64]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- uint64]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfUint64BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan uint64)),
		delete_src:  make(chan (<-chan uint64)),
		add_recv:    make(chan (chan<- uint64)),
		delete_recv: make(chan (chan<- uint64)),
	}
}

func (__ *OfUint64BroadCaster) AddSources(srcs ...<-chan uint64) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfUint64BroadCaster) DeleteSources(srcs ...<-chan uint64) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfUint64BroadCaster) AddReceivers(recvs ...chan<- uint64) *OfUint64BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfUint64BroadCaster) DeleteReceivers(recvs ...chan<- uint64) *OfUint64BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfUint64BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfUint64BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan uint64){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- uint64){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfUint64BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan uint64:
				d := recv.Interface().(uint64)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan uint64):
				d := recv.Interface().(<-chan uint64)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- uint64):
				d := recv.Interface().(chan<- uint64)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfUint8Clear(ch <-chan uint8) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUint8BroadCaster struct {
	srcs        map[<-chan uint8]struct{}
	recvs       map[chan<- uint8]struct{}
	add_src     chan (<-chan uint8)
	delete_src  chan (<-chan uint8)
	add_recv    chan (chan<- uint8)
	delete_recv chan (chan<- uint8)
}

func NewOfUint8BroadCaster(initSrcs []<-chan uint8, initRecvs []chan<- uint8) *OfUint8BroadCaster {
	// fmt.Println("NewOfUint8BroadCaster")
	srcs := make(map[<-chan uint8]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- uint8]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfUint8BroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan uint8)),
		delete_src:  make(chan (<-chan uint8)),
		add_recv:    make(chan (chan<- uint8)),
		delete_recv: make(chan (chan<- uint8)),
	}
}

func (__ *OfUint8BroadCaster) AddSources(srcs ...<-chan uint8) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfUint8BroadCaster) DeleteSources(srcs ...<-chan uint8) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfUint8BroadCaster) AddReceivers(recvs ...chan<- uint8) *OfUint8BroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfUint8BroadCaster) DeleteReceivers(recvs ...chan<- uint8) *OfUint8BroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfUint8BroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfUint8BroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan uint8){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- uint8){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfUint8BroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan uint8:
				d := recv.Interface().(uint8)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan uint8):
				d := recv.Interface().(<-chan uint8)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- uint8):
				d := recv.Interface().(chan<- uint8)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfUintptrClear(ch <-chan uintptr) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUintptrBroadCaster struct {
	srcs        map[<-chan uintptr]struct{}
	recvs       map[chan<- uintptr]struct{}
	add_src     chan (<-chan uintptr)
	delete_src  chan (<-chan uintptr)
	add_recv    chan (chan<- uintptr)
	delete_recv chan (chan<- uintptr)
}

func NewOfUintptrBroadCaster(initSrcs []<-chan uintptr, initRecvs []chan<- uintptr) *OfUintptrBroadCaster {
	// fmt.Println("NewOfUintptrBroadCaster")
	srcs := make(map[<-chan uintptr]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- uintptr]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfUintptrBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan uintptr)),
		delete_src:  make(chan (<-chan uintptr)),
		add_recv:    make(chan (chan<- uintptr)),
		delete_recv: make(chan (chan<- uintptr)),
	}
}

func (__ *OfUintptrBroadCaster) AddSources(srcs ...<-chan uintptr) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfUintptrBroadCaster) DeleteSources(srcs ...<-chan uintptr) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfUintptrBroadCaster) AddReceivers(recvs ...chan<- uintptr) *OfUintptrBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfUintptrBroadCaster) DeleteReceivers(recvs ...chan<- uintptr) *OfUintptrBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfUintptrBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfUintptrBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan uintptr){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- uintptr){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfUintptrBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan uintptr:
				d := recv.Interface().(uintptr)
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan uintptr):
				d := recv.Interface().(<-chan uintptr)
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- uintptr):
				d := recv.Interface().(chan<- uintptr)
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfInterfaceClear(ch <-chan interface{}) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInterfaceBroadCaster struct {
	srcs        map[<-chan interface{}]struct{}
	recvs       map[chan<- interface{}]struct{}
	add_src     chan (<-chan interface{})
	delete_src  chan (<-chan interface{})
	add_recv    chan (chan<- interface{})
	delete_recv chan (chan<- interface{})
}

func NewOfInterfaceBroadCaster(initSrcs []<-chan interface{}, initRecvs []chan<- interface{}) *OfInterfaceBroadCaster {
	// fmt.Println("NewOfInterfaceBroadCaster")
	srcs := make(map[<-chan interface{}]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- interface{}]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfInterfaceBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan interface{})),
		delete_src:  make(chan (<-chan interface{})),
		add_recv:    make(chan (chan<- interface{})),
		delete_recv: make(chan (chan<- interface{})),
	}
}

func (__ *OfInterfaceBroadCaster) AddSources(srcs ...<-chan interface{}) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfInterfaceBroadCaster) DeleteSources(srcs ...<-chan interface{}) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfInterfaceBroadCaster) AddReceivers(recvs ...chan<- interface{}) *OfInterfaceBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfInterfaceBroadCaster) DeleteReceivers(recvs ...chan<- interface{}) *OfInterfaceBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfInterfaceBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfInterfaceBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan interface{}){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- interface{}){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfInterfaceBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan interface{}:
				d := recv.Interface().(interface{})
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan interface{}):
				d := recv.Interface().(<-chan interface{})
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- interface{}):
				d := recv.Interface().(chan<- interface{})
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

func OfStructClear(ch <-chan struct{}) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfStructBroadCaster struct {
	srcs        map[<-chan struct{}]struct{}
	recvs       map[chan<- struct{}]struct{}
	add_src     chan (<-chan struct{})
	delete_src  chan (<-chan struct{})
	add_recv    chan (chan<- struct{})
	delete_recv chan (chan<- struct{})
}

func NewOfStructBroadCaster(initSrcs []<-chan struct{}, initRecvs []chan<- struct{}) *OfStructBroadCaster {
	// fmt.Println("NewOfStructBroadCaster")
	srcs := make(map[<-chan struct{}]struct{})
	for _, src := range initSrcs {
		srcs[src] = struct{}{}
	}
	recvs := make(map[chan<- struct{}]struct{})
	for _, recv := range initRecvs {
		recvs[recv] = struct{}{}
	}

	return &OfStructBroadCaster{
		srcs:        srcs,
		recvs:       recvs,
		add_src:     make(chan (<-chan struct{})),
		delete_src:  make(chan (<-chan struct{})),
		add_recv:    make(chan (chan<- struct{})),
		delete_recv: make(chan (chan<- struct{})),
	}
}

func (__ *OfStructBroadCaster) AddSources(srcs ...<-chan struct{}) {
	// fmt.Println("AddSources")
	for _, src := range srcs {
		__.add_src <- src
	}
}
func (__ *OfStructBroadCaster) DeleteSources(srcs ...<-chan struct{}) {
	// fmt.Println("DeleteSources")
	for _, src := range srcs {
		__.delete_src <- src
	}
}

func (__ *OfStructBroadCaster) AddReceivers(recvs ...chan<- struct{}) *OfStructBroadCaster {
	for _, recv := range recvs {
		__.add_recv <- recv
	}
	return __
}
func (__ *OfStructBroadCaster) DeleteReceivers(recvs ...chan<- struct{}) *OfStructBroadCaster {
	for _, recv := range recvs {
		__.delete_recv <- recv
	}
	return __
}

func (__ *OfStructBroadCaster) len_read_ch() int {
	return len(__.srcs) + 4
}

func (__ *OfStructBroadCaster) collect_chans(done DoneNotifier) []reflect.SelectCase {
	read_cases := make([]reflect.SelectCase, 0, __.len_read_ch()+1)
	for ch := range __.srcs {
		// fmt.Println(ch)
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (<-chan struct{}){__.add_src, __.delete_src} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}
	for _, ch := range []chan (chan<- struct{}){__.add_recv, __.delete_recv} {
		read_cases = append(read_cases, reflect.SelectCase{
			Chan: reflect.ValueOf(ch),
			Dir:  reflect.SelectRecv,
		})
	}

	read_cases = append(read_cases, reflect.SelectCase{
		Chan: reflect.ValueOf(done.Done()),
		Dir:  reflect.SelectRecv,
	})

	return read_cases
}

func (__ *OfStructBroadCaster) ServeThread(ctx context.Context, tctx syncs.ThreadContext) error {
	// fmt.Println("ServeThread")
	th_cnt := syncs.ThreadCounterFrom(ctx)
	ok := th_cnt.AddOrNot(1)
	if !ok {
		return fmt.Errorf("cannot serve thread: context done")
	}

	go func() {
		defer th_cnt.Done()
		defer func() {
			// fmt.Println("defer")
			for ch := range __.recvs {
				close(ch)
			}
		}()
	loop:
		for {
			cases := __.collect_chans(ctx)
			// fmt.Println(cases)
			chosen, recv, recv_ok := reflect.Select(cases)
			if !recv_ok {
				tctx.Break(fmt.Errorf("receive channel #%v is broken", chosen))
				break loop
			}
			// fmt.Println(chosen, recv, recv_ok)
			switch ch := cases[chosen].Chan.Interface().(type) {
			// srcs
			case <-chan struct{}:
				d := recv.Interface().(struct{})
				for recv := range __.recvs {
					select {
					case recv <- d:
					default:
					}
				}
				// add/delete src
			case chan (<-chan struct{}):
				d := recv.Interface().(<-chan struct{})
				switch ch {
				case __.add_src:
					__.srcs[d] = struct{}{}
				case __.delete_src:
					delete(__.srcs, d)
				}
				// add/delete recv
			case chan (chan<- struct{}):
				d := recv.Interface().(chan<- struct{})
				switch ch {
				case __.add_recv:
					__.recvs[d] = struct{}{}
				case __.delete_recv:
					delete(__.recvs, d)
					close(d)
				}
			default:
				fmt.Println("terminate")
				break loop
			}

		}
	}()
	return nil
}

// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

import (
	"context"
	"fmt"
	"reflect"

	"github.com/mark-ahn/hexa"
)

type OfBoolMultiCaster struct {
	in  []<-chan bool
	out []chan<- bool
}

func NewOfBoolMultiCaster() *OfBoolMultiCaster {
	return &OfBoolMultiCaster{
		in:  make([]<-chan bool, 0),
		out: make([]chan<- bool, 0),
	}
}

func (__ *OfBoolMultiCaster) AddSources(ins ...<-chan bool) *OfBoolMultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfBoolMultiCaster) Add(outs ...chan<- bool) *OfBoolMultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfBoolMultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(bool)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfByteMultiCaster struct {
	in  []<-chan byte
	out []chan<- byte
}

func NewOfByteMultiCaster() *OfByteMultiCaster {
	return &OfByteMultiCaster{
		in:  make([]<-chan byte, 0),
		out: make([]chan<- byte, 0),
	}
}

func (__ *OfByteMultiCaster) AddSources(ins ...<-chan byte) *OfByteMultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfByteMultiCaster) Add(outs ...chan<- byte) *OfByteMultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfByteMultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(byte)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfComplex128MultiCaster struct {
	in  []<-chan complex128
	out []chan<- complex128
}

func NewOfComplex128MultiCaster() *OfComplex128MultiCaster {
	return &OfComplex128MultiCaster{
		in:  make([]<-chan complex128, 0),
		out: make([]chan<- complex128, 0),
	}
}

func (__ *OfComplex128MultiCaster) AddSources(ins ...<-chan complex128) *OfComplex128MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfComplex128MultiCaster) Add(outs ...chan<- complex128) *OfComplex128MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfComplex128MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(complex128)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfComplex64MultiCaster struct {
	in  []<-chan complex64
	out []chan<- complex64
}

func NewOfComplex64MultiCaster() *OfComplex64MultiCaster {
	return &OfComplex64MultiCaster{
		in:  make([]<-chan complex64, 0),
		out: make([]chan<- complex64, 0),
	}
}

func (__ *OfComplex64MultiCaster) AddSources(ins ...<-chan complex64) *OfComplex64MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfComplex64MultiCaster) Add(outs ...chan<- complex64) *OfComplex64MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfComplex64MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(complex64)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfErrorMultiCaster struct {
	in  []<-chan error
	out []chan<- error
}

func NewOfErrorMultiCaster() *OfErrorMultiCaster {
	return &OfErrorMultiCaster{
		in:  make([]<-chan error, 0),
		out: make([]chan<- error, 0),
	}
}

func (__ *OfErrorMultiCaster) AddSources(ins ...<-chan error) *OfErrorMultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfErrorMultiCaster) Add(outs ...chan<- error) *OfErrorMultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfErrorMultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(error)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfFloat32MultiCaster struct {
	in  []<-chan float32
	out []chan<- float32
}

func NewOfFloat32MultiCaster() *OfFloat32MultiCaster {
	return &OfFloat32MultiCaster{
		in:  make([]<-chan float32, 0),
		out: make([]chan<- float32, 0),
	}
}

func (__ *OfFloat32MultiCaster) AddSources(ins ...<-chan float32) *OfFloat32MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfFloat32MultiCaster) Add(outs ...chan<- float32) *OfFloat32MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfFloat32MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(float32)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfFloat64MultiCaster struct {
	in  []<-chan float64
	out []chan<- float64
}

func NewOfFloat64MultiCaster() *OfFloat64MultiCaster {
	return &OfFloat64MultiCaster{
		in:  make([]<-chan float64, 0),
		out: make([]chan<- float64, 0),
	}
}

func (__ *OfFloat64MultiCaster) AddSources(ins ...<-chan float64) *OfFloat64MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfFloat64MultiCaster) Add(outs ...chan<- float64) *OfFloat64MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfFloat64MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(float64)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfIntMultiCaster struct {
	in  []<-chan int
	out []chan<- int
}

func NewOfIntMultiCaster() *OfIntMultiCaster {
	return &OfIntMultiCaster{
		in:  make([]<-chan int, 0),
		out: make([]chan<- int, 0),
	}
}

func (__ *OfIntMultiCaster) AddSources(ins ...<-chan int) *OfIntMultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfIntMultiCaster) Add(outs ...chan<- int) *OfIntMultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfIntMultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfInt16MultiCaster struct {
	in  []<-chan int16
	out []chan<- int16
}

func NewOfInt16MultiCaster() *OfInt16MultiCaster {
	return &OfInt16MultiCaster{
		in:  make([]<-chan int16, 0),
		out: make([]chan<- int16, 0),
	}
}

func (__ *OfInt16MultiCaster) AddSources(ins ...<-chan int16) *OfInt16MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInt16MultiCaster) Add(outs ...chan<- int16) *OfInt16MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInt16MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int16)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfInt32MultiCaster struct {
	in  []<-chan int32
	out []chan<- int32
}

func NewOfInt32MultiCaster() *OfInt32MultiCaster {
	return &OfInt32MultiCaster{
		in:  make([]<-chan int32, 0),
		out: make([]chan<- int32, 0),
	}
}

func (__ *OfInt32MultiCaster) AddSources(ins ...<-chan int32) *OfInt32MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInt32MultiCaster) Add(outs ...chan<- int32) *OfInt32MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInt32MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int32)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfInt64MultiCaster struct {
	in  []<-chan int64
	out []chan<- int64
}

func NewOfInt64MultiCaster() *OfInt64MultiCaster {
	return &OfInt64MultiCaster{
		in:  make([]<-chan int64, 0),
		out: make([]chan<- int64, 0),
	}
}

func (__ *OfInt64MultiCaster) AddSources(ins ...<-chan int64) *OfInt64MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInt64MultiCaster) Add(outs ...chan<- int64) *OfInt64MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInt64MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int64)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfInt8MultiCaster struct {
	in  []<-chan int8
	out []chan<- int8
}

func NewOfInt8MultiCaster() *OfInt8MultiCaster {
	return &OfInt8MultiCaster{
		in:  make([]<-chan int8, 0),
		out: make([]chan<- int8, 0),
	}
}

func (__ *OfInt8MultiCaster) AddSources(ins ...<-chan int8) *OfInt8MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInt8MultiCaster) Add(outs ...chan<- int8) *OfInt8MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInt8MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int8)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfRuneMultiCaster struct {
	in  []<-chan rune
	out []chan<- rune
}

func NewOfRuneMultiCaster() *OfRuneMultiCaster {
	return &OfRuneMultiCaster{
		in:  make([]<-chan rune, 0),
		out: make([]chan<- rune, 0),
	}
}

func (__ *OfRuneMultiCaster) AddSources(ins ...<-chan rune) *OfRuneMultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfRuneMultiCaster) Add(outs ...chan<- rune) *OfRuneMultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfRuneMultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(rune)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfStringMultiCaster struct {
	in  []<-chan string
	out []chan<- string
}

func NewOfStringMultiCaster() *OfStringMultiCaster {
	return &OfStringMultiCaster{
		in:  make([]<-chan string, 0),
		out: make([]chan<- string, 0),
	}
}

func (__ *OfStringMultiCaster) AddSources(ins ...<-chan string) *OfStringMultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfStringMultiCaster) Add(outs ...chan<- string) *OfStringMultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfStringMultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(string)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfUintMultiCaster struct {
	in  []<-chan uint
	out []chan<- uint
}

func NewOfUintMultiCaster() *OfUintMultiCaster {
	return &OfUintMultiCaster{
		in:  make([]<-chan uint, 0),
		out: make([]chan<- uint, 0),
	}
}

func (__ *OfUintMultiCaster) AddSources(ins ...<-chan uint) *OfUintMultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUintMultiCaster) Add(outs ...chan<- uint) *OfUintMultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUintMultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfUint16MultiCaster struct {
	in  []<-chan uint16
	out []chan<- uint16
}

func NewOfUint16MultiCaster() *OfUint16MultiCaster {
	return &OfUint16MultiCaster{
		in:  make([]<-chan uint16, 0),
		out: make([]chan<- uint16, 0),
	}
}

func (__ *OfUint16MultiCaster) AddSources(ins ...<-chan uint16) *OfUint16MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUint16MultiCaster) Add(outs ...chan<- uint16) *OfUint16MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUint16MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint16)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfUint32MultiCaster struct {
	in  []<-chan uint32
	out []chan<- uint32
}

func NewOfUint32MultiCaster() *OfUint32MultiCaster {
	return &OfUint32MultiCaster{
		in:  make([]<-chan uint32, 0),
		out: make([]chan<- uint32, 0),
	}
}

func (__ *OfUint32MultiCaster) AddSources(ins ...<-chan uint32) *OfUint32MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUint32MultiCaster) Add(outs ...chan<- uint32) *OfUint32MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUint32MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint32)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfUint64MultiCaster struct {
	in  []<-chan uint64
	out []chan<- uint64
}

func NewOfUint64MultiCaster() *OfUint64MultiCaster {
	return &OfUint64MultiCaster{
		in:  make([]<-chan uint64, 0),
		out: make([]chan<- uint64, 0),
	}
}

func (__ *OfUint64MultiCaster) AddSources(ins ...<-chan uint64) *OfUint64MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUint64MultiCaster) Add(outs ...chan<- uint64) *OfUint64MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUint64MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint64)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfUint8MultiCaster struct {
	in  []<-chan uint8
	out []chan<- uint8
}

func NewOfUint8MultiCaster() *OfUint8MultiCaster {
	return &OfUint8MultiCaster{
		in:  make([]<-chan uint8, 0),
		out: make([]chan<- uint8, 0),
	}
}

func (__ *OfUint8MultiCaster) AddSources(ins ...<-chan uint8) *OfUint8MultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUint8MultiCaster) Add(outs ...chan<- uint8) *OfUint8MultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUint8MultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint8)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfUintptrMultiCaster struct {
	in  []<-chan uintptr
	out []chan<- uintptr
}

func NewOfUintptrMultiCaster() *OfUintptrMultiCaster {
	return &OfUintptrMultiCaster{
		in:  make([]<-chan uintptr, 0),
		out: make([]chan<- uintptr, 0),
	}
}

func (__ *OfUintptrMultiCaster) AddSources(ins ...<-chan uintptr) *OfUintptrMultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUintptrMultiCaster) Add(outs ...chan<- uintptr) *OfUintptrMultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUintptrMultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uintptr)
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

type OfInterfaceMultiCaster struct {
	in  []<-chan interface{}
	out []chan<- interface{}
}

func NewOfInterfaceMultiCaster() *OfInterfaceMultiCaster {
	return &OfInterfaceMultiCaster{
		in:  make([]<-chan interface{}, 0),
		out: make([]chan<- interface{}, 0),
	}
}

func (__ *OfInterfaceMultiCaster) AddSources(ins ...<-chan interface{}) *OfInterfaceMultiCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInterfaceMultiCaster) Add(outs ...chan<- interface{}) *OfInterfaceMultiCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInterfaceMultiCaster) Serve() hexa.StoppableOne {
	dctx := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			dctx.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(dctx.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(interface{})
			if !ok {
				dctx.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return dctx
}

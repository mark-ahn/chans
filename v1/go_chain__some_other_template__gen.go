// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

import "time"

func (__ *GoChain) MapBytesToBytes(recv <-chan Bytes, send chan<- Bytes, mapF func(Bytes, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan Bytes = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrBytes(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToBool(recv <-chan Bytes, send chan<- bool, mapF func(Bytes, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan Bytes = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrBool(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToByte(recv <-chan Bytes, send chan<- byte, mapF func(Bytes, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan Bytes = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrByte(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToComplex128(recv <-chan Bytes, send chan<- complex128, mapF func(Bytes, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan Bytes = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrComplex128(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToComplex64(recv <-chan Bytes, send chan<- complex64, mapF func(Bytes, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan Bytes = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrComplex64(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToError(recv <-chan Bytes, send chan<- error, mapF func(Bytes, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan Bytes = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrError(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToFloat32(recv <-chan Bytes, send chan<- float32, mapF func(Bytes, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan Bytes = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrFloat32(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToFloat64(recv <-chan Bytes, send chan<- float64, mapF func(Bytes, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan Bytes = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrFloat64(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToInt(recv <-chan Bytes, send chan<- int, mapF func(Bytes, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan Bytes = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrInt(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToInt16(recv <-chan Bytes, send chan<- int16, mapF func(Bytes, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan Bytes = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrInt16(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToInt32(recv <-chan Bytes, send chan<- int32, mapF func(Bytes, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan Bytes = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrInt32(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToInt64(recv <-chan Bytes, send chan<- int64, mapF func(Bytes, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan Bytes = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrInt64(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToInt8(recv <-chan Bytes, send chan<- int8, mapF func(Bytes, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan Bytes = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrInt8(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToRune(recv <-chan Bytes, send chan<- rune, mapF func(Bytes, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan Bytes = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrRune(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToString(recv <-chan Bytes, send chan<- string, mapF func(Bytes, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan Bytes = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrString(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToUint(recv <-chan Bytes, send chan<- uint, mapF func(Bytes, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan Bytes = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrUint(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToUint16(recv <-chan Bytes, send chan<- uint16, mapF func(Bytes, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan Bytes = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrUint16(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToUint32(recv <-chan Bytes, send chan<- uint32, mapF func(Bytes, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan Bytes = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrUint32(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToUint64(recv <-chan Bytes, send chan<- uint64, mapF func(Bytes, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan Bytes = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrUint64(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToUint8(recv <-chan Bytes, send chan<- uint8, mapF func(Bytes, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan Bytes = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrUint8(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToUintptr(recv <-chan Bytes, send chan<- uintptr, mapF func(Bytes, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan Bytes = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrUintptr(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToInterface(recv <-chan Bytes, send chan<- interface{}, mapF func(Bytes, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan Bytes = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrInterface(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToStruct(recv <-chan Bytes, send chan<- struct{}, mapF func(Bytes, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan Bytes = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrStruct(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBytesToTimeTime(recv <-chan Bytes, send chan<- time.Time, mapF func(Bytes, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan Bytes = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBytesOrTimeTime(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToBytes(recv <-chan bool, send chan<- Bytes, mapF func(bool, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan bool = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrBytes(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToBool(recv <-chan bool, send chan<- bool, mapF func(bool, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan bool = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrBool(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToByte(recv <-chan bool, send chan<- byte, mapF func(bool, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan bool = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrByte(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToComplex128(recv <-chan bool, send chan<- complex128, mapF func(bool, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan bool = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrComplex128(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToComplex64(recv <-chan bool, send chan<- complex64, mapF func(bool, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan bool = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrComplex64(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToError(recv <-chan bool, send chan<- error, mapF func(bool, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan bool = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrError(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToFloat32(recv <-chan bool, send chan<- float32, mapF func(bool, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan bool = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrFloat32(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToFloat64(recv <-chan bool, send chan<- float64, mapF func(bool, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan bool = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrFloat64(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToInt(recv <-chan bool, send chan<- int, mapF func(bool, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan bool = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrInt(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToInt16(recv <-chan bool, send chan<- int16, mapF func(bool, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan bool = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrInt16(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToInt32(recv <-chan bool, send chan<- int32, mapF func(bool, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan bool = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrInt32(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToInt64(recv <-chan bool, send chan<- int64, mapF func(bool, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan bool = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrInt64(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToInt8(recv <-chan bool, send chan<- int8, mapF func(bool, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan bool = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrInt8(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToRune(recv <-chan bool, send chan<- rune, mapF func(bool, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan bool = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrRune(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToString(recv <-chan bool, send chan<- string, mapF func(bool, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan bool = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrString(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToUint(recv <-chan bool, send chan<- uint, mapF func(bool, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan bool = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrUint(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToUint16(recv <-chan bool, send chan<- uint16, mapF func(bool, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan bool = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrUint16(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToUint32(recv <-chan bool, send chan<- uint32, mapF func(bool, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan bool = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrUint32(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToUint64(recv <-chan bool, send chan<- uint64, mapF func(bool, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan bool = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrUint64(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToUint8(recv <-chan bool, send chan<- uint8, mapF func(bool, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan bool = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrUint8(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToUintptr(recv <-chan bool, send chan<- uintptr, mapF func(bool, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan bool = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrUintptr(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToInterface(recv <-chan bool, send chan<- interface{}, mapF func(bool, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan bool = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrInterface(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToStruct(recv <-chan bool, send chan<- struct{}, mapF func(bool, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan bool = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrStruct(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapBoolToTimeTime(recv <-chan bool, send chan<- time.Time, mapF func(bool, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan bool = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendBoolOrTimeTime(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToBytes(recv <-chan byte, send chan<- Bytes, mapF func(byte, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan byte = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrBytes(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToBool(recv <-chan byte, send chan<- bool, mapF func(byte, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan byte = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrBool(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToByte(recv <-chan byte, send chan<- byte, mapF func(byte, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan byte = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrByte(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToComplex128(recv <-chan byte, send chan<- complex128, mapF func(byte, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan byte = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrComplex128(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToComplex64(recv <-chan byte, send chan<- complex64, mapF func(byte, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan byte = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrComplex64(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToError(recv <-chan byte, send chan<- error, mapF func(byte, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan byte = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrError(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToFloat32(recv <-chan byte, send chan<- float32, mapF func(byte, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan byte = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrFloat32(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToFloat64(recv <-chan byte, send chan<- float64, mapF func(byte, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan byte = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrFloat64(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToInt(recv <-chan byte, send chan<- int, mapF func(byte, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan byte = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrInt(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToInt16(recv <-chan byte, send chan<- int16, mapF func(byte, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan byte = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrInt16(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToInt32(recv <-chan byte, send chan<- int32, mapF func(byte, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan byte = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrInt32(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToInt64(recv <-chan byte, send chan<- int64, mapF func(byte, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan byte = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrInt64(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToInt8(recv <-chan byte, send chan<- int8, mapF func(byte, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan byte = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrInt8(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToRune(recv <-chan byte, send chan<- rune, mapF func(byte, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan byte = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrRune(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToString(recv <-chan byte, send chan<- string, mapF func(byte, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan byte = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrString(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToUint(recv <-chan byte, send chan<- uint, mapF func(byte, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan byte = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrUint(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToUint16(recv <-chan byte, send chan<- uint16, mapF func(byte, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan byte = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrUint16(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToUint32(recv <-chan byte, send chan<- uint32, mapF func(byte, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan byte = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrUint32(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToUint64(recv <-chan byte, send chan<- uint64, mapF func(byte, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan byte = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrUint64(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToUint8(recv <-chan byte, send chan<- uint8, mapF func(byte, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan byte = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrUint8(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToUintptr(recv <-chan byte, send chan<- uintptr, mapF func(byte, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan byte = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrUintptr(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToInterface(recv <-chan byte, send chan<- interface{}, mapF func(byte, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan byte = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrInterface(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToStruct(recv <-chan byte, send chan<- struct{}, mapF func(byte, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan byte = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrStruct(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapByteToTimeTime(recv <-chan byte, send chan<- time.Time, mapF func(byte, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan byte = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendByteOrTimeTime(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToBytes(recv <-chan complex128, send chan<- Bytes, mapF func(complex128, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan complex128 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrBytes(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToBool(recv <-chan complex128, send chan<- bool, mapF func(complex128, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan complex128 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrBool(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToByte(recv <-chan complex128, send chan<- byte, mapF func(complex128, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan complex128 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrByte(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToComplex128(recv <-chan complex128, send chan<- complex128, mapF func(complex128, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan complex128 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrComplex128(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToComplex64(recv <-chan complex128, send chan<- complex64, mapF func(complex128, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan complex128 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrComplex64(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToError(recv <-chan complex128, send chan<- error, mapF func(complex128, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan complex128 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrError(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToFloat32(recv <-chan complex128, send chan<- float32, mapF func(complex128, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan complex128 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrFloat32(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToFloat64(recv <-chan complex128, send chan<- float64, mapF func(complex128, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan complex128 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrFloat64(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToInt(recv <-chan complex128, send chan<- int, mapF func(complex128, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan complex128 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrInt(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToInt16(recv <-chan complex128, send chan<- int16, mapF func(complex128, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan complex128 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrInt16(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToInt32(recv <-chan complex128, send chan<- int32, mapF func(complex128, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan complex128 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrInt32(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToInt64(recv <-chan complex128, send chan<- int64, mapF func(complex128, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan complex128 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrInt64(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToInt8(recv <-chan complex128, send chan<- int8, mapF func(complex128, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan complex128 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrInt8(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToRune(recv <-chan complex128, send chan<- rune, mapF func(complex128, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan complex128 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrRune(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToString(recv <-chan complex128, send chan<- string, mapF func(complex128, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan complex128 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrString(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToUint(recv <-chan complex128, send chan<- uint, mapF func(complex128, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan complex128 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrUint(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToUint16(recv <-chan complex128, send chan<- uint16, mapF func(complex128, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan complex128 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrUint16(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToUint32(recv <-chan complex128, send chan<- uint32, mapF func(complex128, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan complex128 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrUint32(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToUint64(recv <-chan complex128, send chan<- uint64, mapF func(complex128, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan complex128 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrUint64(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToUint8(recv <-chan complex128, send chan<- uint8, mapF func(complex128, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan complex128 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrUint8(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToUintptr(recv <-chan complex128, send chan<- uintptr, mapF func(complex128, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan complex128 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrUintptr(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToInterface(recv <-chan complex128, send chan<- interface{}, mapF func(complex128, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan complex128 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrInterface(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToStruct(recv <-chan complex128, send chan<- struct{}, mapF func(complex128, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan complex128 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrStruct(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex128ToTimeTime(recv <-chan complex128, send chan<- time.Time, mapF func(complex128, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan complex128 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex128OrTimeTime(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToBytes(recv <-chan complex64, send chan<- Bytes, mapF func(complex64, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan complex64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrBytes(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToBool(recv <-chan complex64, send chan<- bool, mapF func(complex64, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan complex64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrBool(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToByte(recv <-chan complex64, send chan<- byte, mapF func(complex64, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan complex64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrByte(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToComplex128(recv <-chan complex64, send chan<- complex128, mapF func(complex64, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan complex64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrComplex128(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToComplex64(recv <-chan complex64, send chan<- complex64, mapF func(complex64, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan complex64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrComplex64(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToError(recv <-chan complex64, send chan<- error, mapF func(complex64, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan complex64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrError(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToFloat32(recv <-chan complex64, send chan<- float32, mapF func(complex64, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan complex64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrFloat32(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToFloat64(recv <-chan complex64, send chan<- float64, mapF func(complex64, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan complex64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrFloat64(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToInt(recv <-chan complex64, send chan<- int, mapF func(complex64, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan complex64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrInt(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToInt16(recv <-chan complex64, send chan<- int16, mapF func(complex64, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan complex64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrInt16(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToInt32(recv <-chan complex64, send chan<- int32, mapF func(complex64, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan complex64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrInt32(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToInt64(recv <-chan complex64, send chan<- int64, mapF func(complex64, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan complex64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrInt64(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToInt8(recv <-chan complex64, send chan<- int8, mapF func(complex64, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan complex64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrInt8(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToRune(recv <-chan complex64, send chan<- rune, mapF func(complex64, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan complex64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrRune(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToString(recv <-chan complex64, send chan<- string, mapF func(complex64, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan complex64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrString(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToUint(recv <-chan complex64, send chan<- uint, mapF func(complex64, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan complex64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrUint(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToUint16(recv <-chan complex64, send chan<- uint16, mapF func(complex64, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan complex64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrUint16(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToUint32(recv <-chan complex64, send chan<- uint32, mapF func(complex64, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan complex64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrUint32(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToUint64(recv <-chan complex64, send chan<- uint64, mapF func(complex64, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan complex64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrUint64(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToUint8(recv <-chan complex64, send chan<- uint8, mapF func(complex64, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan complex64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrUint8(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToUintptr(recv <-chan complex64, send chan<- uintptr, mapF func(complex64, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan complex64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrUintptr(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToInterface(recv <-chan complex64, send chan<- interface{}, mapF func(complex64, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan complex64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrInterface(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToStruct(recv <-chan complex64, send chan<- struct{}, mapF func(complex64, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan complex64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrStruct(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapComplex64ToTimeTime(recv <-chan complex64, send chan<- time.Time, mapF func(complex64, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan complex64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendComplex64OrTimeTime(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToBytes(recv <-chan error, send chan<- Bytes, mapF func(error, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan error = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrBytes(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToBool(recv <-chan error, send chan<- bool, mapF func(error, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan error = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrBool(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToByte(recv <-chan error, send chan<- byte, mapF func(error, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan error = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrByte(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToComplex128(recv <-chan error, send chan<- complex128, mapF func(error, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan error = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrComplex128(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToComplex64(recv <-chan error, send chan<- complex64, mapF func(error, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan error = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrComplex64(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToError(recv <-chan error, send chan<- error, mapF func(error, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan error = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrError(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToFloat32(recv <-chan error, send chan<- float32, mapF func(error, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan error = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrFloat32(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToFloat64(recv <-chan error, send chan<- float64, mapF func(error, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan error = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrFloat64(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToInt(recv <-chan error, send chan<- int, mapF func(error, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan error = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrInt(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToInt16(recv <-chan error, send chan<- int16, mapF func(error, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan error = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrInt16(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToInt32(recv <-chan error, send chan<- int32, mapF func(error, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan error = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrInt32(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToInt64(recv <-chan error, send chan<- int64, mapF func(error, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan error = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrInt64(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToInt8(recv <-chan error, send chan<- int8, mapF func(error, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan error = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrInt8(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToRune(recv <-chan error, send chan<- rune, mapF func(error, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan error = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrRune(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToString(recv <-chan error, send chan<- string, mapF func(error, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan error = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrString(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToUint(recv <-chan error, send chan<- uint, mapF func(error, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan error = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrUint(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToUint16(recv <-chan error, send chan<- uint16, mapF func(error, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan error = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrUint16(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToUint32(recv <-chan error, send chan<- uint32, mapF func(error, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan error = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrUint32(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToUint64(recv <-chan error, send chan<- uint64, mapF func(error, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan error = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrUint64(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToUint8(recv <-chan error, send chan<- uint8, mapF func(error, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan error = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrUint8(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToUintptr(recv <-chan error, send chan<- uintptr, mapF func(error, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan error = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrUintptr(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToInterface(recv <-chan error, send chan<- interface{}, mapF func(error, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan error = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrInterface(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToStruct(recv <-chan error, send chan<- struct{}, mapF func(error, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan error = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrStruct(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapErrorToTimeTime(recv <-chan error, send chan<- time.Time, mapF func(error, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan error = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendErrorOrTimeTime(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToBytes(recv <-chan float32, send chan<- Bytes, mapF func(float32, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan float32 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrBytes(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToBool(recv <-chan float32, send chan<- bool, mapF func(float32, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan float32 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrBool(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToByte(recv <-chan float32, send chan<- byte, mapF func(float32, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan float32 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrByte(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToComplex128(recv <-chan float32, send chan<- complex128, mapF func(float32, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan float32 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrComplex128(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToComplex64(recv <-chan float32, send chan<- complex64, mapF func(float32, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan float32 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrComplex64(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToError(recv <-chan float32, send chan<- error, mapF func(float32, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan float32 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrError(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToFloat32(recv <-chan float32, send chan<- float32, mapF func(float32, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan float32 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrFloat32(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToFloat64(recv <-chan float32, send chan<- float64, mapF func(float32, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan float32 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrFloat64(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToInt(recv <-chan float32, send chan<- int, mapF func(float32, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan float32 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrInt(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToInt16(recv <-chan float32, send chan<- int16, mapF func(float32, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan float32 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrInt16(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToInt32(recv <-chan float32, send chan<- int32, mapF func(float32, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan float32 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrInt32(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToInt64(recv <-chan float32, send chan<- int64, mapF func(float32, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan float32 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrInt64(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToInt8(recv <-chan float32, send chan<- int8, mapF func(float32, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan float32 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrInt8(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToRune(recv <-chan float32, send chan<- rune, mapF func(float32, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan float32 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrRune(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToString(recv <-chan float32, send chan<- string, mapF func(float32, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan float32 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrString(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToUint(recv <-chan float32, send chan<- uint, mapF func(float32, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan float32 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrUint(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToUint16(recv <-chan float32, send chan<- uint16, mapF func(float32, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan float32 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrUint16(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToUint32(recv <-chan float32, send chan<- uint32, mapF func(float32, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan float32 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrUint32(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToUint64(recv <-chan float32, send chan<- uint64, mapF func(float32, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan float32 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrUint64(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToUint8(recv <-chan float32, send chan<- uint8, mapF func(float32, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan float32 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrUint8(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToUintptr(recv <-chan float32, send chan<- uintptr, mapF func(float32, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan float32 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrUintptr(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToInterface(recv <-chan float32, send chan<- interface{}, mapF func(float32, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan float32 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrInterface(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToStruct(recv <-chan float32, send chan<- struct{}, mapF func(float32, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan float32 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrStruct(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat32ToTimeTime(recv <-chan float32, send chan<- time.Time, mapF func(float32, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan float32 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat32OrTimeTime(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToBytes(recv <-chan float64, send chan<- Bytes, mapF func(float64, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan float64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrBytes(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToBool(recv <-chan float64, send chan<- bool, mapF func(float64, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan float64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrBool(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToByte(recv <-chan float64, send chan<- byte, mapF func(float64, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan float64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrByte(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToComplex128(recv <-chan float64, send chan<- complex128, mapF func(float64, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan float64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrComplex128(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToComplex64(recv <-chan float64, send chan<- complex64, mapF func(float64, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan float64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrComplex64(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToError(recv <-chan float64, send chan<- error, mapF func(float64, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan float64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrError(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToFloat32(recv <-chan float64, send chan<- float32, mapF func(float64, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan float64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrFloat32(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToFloat64(recv <-chan float64, send chan<- float64, mapF func(float64, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan float64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrFloat64(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToInt(recv <-chan float64, send chan<- int, mapF func(float64, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan float64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrInt(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToInt16(recv <-chan float64, send chan<- int16, mapF func(float64, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan float64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrInt16(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToInt32(recv <-chan float64, send chan<- int32, mapF func(float64, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan float64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrInt32(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToInt64(recv <-chan float64, send chan<- int64, mapF func(float64, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan float64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrInt64(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToInt8(recv <-chan float64, send chan<- int8, mapF func(float64, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan float64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrInt8(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToRune(recv <-chan float64, send chan<- rune, mapF func(float64, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan float64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrRune(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToString(recv <-chan float64, send chan<- string, mapF func(float64, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan float64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrString(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToUint(recv <-chan float64, send chan<- uint, mapF func(float64, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan float64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrUint(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToUint16(recv <-chan float64, send chan<- uint16, mapF func(float64, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan float64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrUint16(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToUint32(recv <-chan float64, send chan<- uint32, mapF func(float64, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan float64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrUint32(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToUint64(recv <-chan float64, send chan<- uint64, mapF func(float64, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan float64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrUint64(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToUint8(recv <-chan float64, send chan<- uint8, mapF func(float64, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan float64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrUint8(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToUintptr(recv <-chan float64, send chan<- uintptr, mapF func(float64, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan float64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrUintptr(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToInterface(recv <-chan float64, send chan<- interface{}, mapF func(float64, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan float64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrInterface(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToStruct(recv <-chan float64, send chan<- struct{}, mapF func(float64, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan float64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrStruct(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapFloat64ToTimeTime(recv <-chan float64, send chan<- time.Time, mapF func(float64, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan float64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendFloat64OrTimeTime(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToBytes(recv <-chan int, send chan<- Bytes, mapF func(int, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrBytes(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToBool(recv <-chan int, send chan<- bool, mapF func(int, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrBool(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToByte(recv <-chan int, send chan<- byte, mapF func(int, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrByte(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToComplex128(recv <-chan int, send chan<- complex128, mapF func(int, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrComplex128(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToComplex64(recv <-chan int, send chan<- complex64, mapF func(int, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrComplex64(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToError(recv <-chan int, send chan<- error, mapF func(int, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrError(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToFloat32(recv <-chan int, send chan<- float32, mapF func(int, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrFloat32(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToFloat64(recv <-chan int, send chan<- float64, mapF func(int, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrFloat64(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToInt(recv <-chan int, send chan<- int, mapF func(int, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrInt(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToInt16(recv <-chan int, send chan<- int16, mapF func(int, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrInt16(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToInt32(recv <-chan int, send chan<- int32, mapF func(int, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrInt32(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToInt64(recv <-chan int, send chan<- int64, mapF func(int, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrInt64(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToInt8(recv <-chan int, send chan<- int8, mapF func(int, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrInt8(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToRune(recv <-chan int, send chan<- rune, mapF func(int, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrRune(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToString(recv <-chan int, send chan<- string, mapF func(int, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrString(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToUint(recv <-chan int, send chan<- uint, mapF func(int, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrUint(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToUint16(recv <-chan int, send chan<- uint16, mapF func(int, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrUint16(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToUint32(recv <-chan int, send chan<- uint32, mapF func(int, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrUint32(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToUint64(recv <-chan int, send chan<- uint64, mapF func(int, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrUint64(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToUint8(recv <-chan int, send chan<- uint8, mapF func(int, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrUint8(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToUintptr(recv <-chan int, send chan<- uintptr, mapF func(int, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrUintptr(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToInterface(recv <-chan int, send chan<- interface{}, mapF func(int, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrInterface(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToStruct(recv <-chan int, send chan<- struct{}, mapF func(int, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrStruct(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapIntToTimeTime(recv <-chan int, send chan<- time.Time, mapF func(int, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendIntOrTimeTime(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToBytes(recv <-chan int16, send chan<- Bytes, mapF func(int16, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int16 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrBytes(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToBool(recv <-chan int16, send chan<- bool, mapF func(int16, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int16 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrBool(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToByte(recv <-chan int16, send chan<- byte, mapF func(int16, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int16 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrByte(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToComplex128(recv <-chan int16, send chan<- complex128, mapF func(int16, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int16 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrComplex128(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToComplex64(recv <-chan int16, send chan<- complex64, mapF func(int16, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int16 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrComplex64(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToError(recv <-chan int16, send chan<- error, mapF func(int16, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int16 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrError(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToFloat32(recv <-chan int16, send chan<- float32, mapF func(int16, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int16 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrFloat32(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToFloat64(recv <-chan int16, send chan<- float64, mapF func(int16, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int16 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrFloat64(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToInt(recv <-chan int16, send chan<- int, mapF func(int16, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int16 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrInt(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToInt16(recv <-chan int16, send chan<- int16, mapF func(int16, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int16 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrInt16(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToInt32(recv <-chan int16, send chan<- int32, mapF func(int16, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int16 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrInt32(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToInt64(recv <-chan int16, send chan<- int64, mapF func(int16, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int16 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrInt64(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToInt8(recv <-chan int16, send chan<- int8, mapF func(int16, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int16 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrInt8(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToRune(recv <-chan int16, send chan<- rune, mapF func(int16, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int16 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrRune(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToString(recv <-chan int16, send chan<- string, mapF func(int16, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int16 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrString(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToUint(recv <-chan int16, send chan<- uint, mapF func(int16, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int16 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrUint(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToUint16(recv <-chan int16, send chan<- uint16, mapF func(int16, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int16 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrUint16(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToUint32(recv <-chan int16, send chan<- uint32, mapF func(int16, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int16 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrUint32(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToUint64(recv <-chan int16, send chan<- uint64, mapF func(int16, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int16 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrUint64(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToUint8(recv <-chan int16, send chan<- uint8, mapF func(int16, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int16 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrUint8(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToUintptr(recv <-chan int16, send chan<- uintptr, mapF func(int16, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int16 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrUintptr(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToInterface(recv <-chan int16, send chan<- interface{}, mapF func(int16, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int16 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrInterface(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToStruct(recv <-chan int16, send chan<- struct{}, mapF func(int16, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int16 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrStruct(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt16ToTimeTime(recv <-chan int16, send chan<- time.Time, mapF func(int16, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int16 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt16OrTimeTime(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToBytes(recv <-chan int32, send chan<- Bytes, mapF func(int32, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int32 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrBytes(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToBool(recv <-chan int32, send chan<- bool, mapF func(int32, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int32 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrBool(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToByte(recv <-chan int32, send chan<- byte, mapF func(int32, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int32 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrByte(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToComplex128(recv <-chan int32, send chan<- complex128, mapF func(int32, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int32 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrComplex128(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToComplex64(recv <-chan int32, send chan<- complex64, mapF func(int32, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int32 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrComplex64(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToError(recv <-chan int32, send chan<- error, mapF func(int32, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int32 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrError(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToFloat32(recv <-chan int32, send chan<- float32, mapF func(int32, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int32 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrFloat32(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToFloat64(recv <-chan int32, send chan<- float64, mapF func(int32, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int32 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrFloat64(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToInt(recv <-chan int32, send chan<- int, mapF func(int32, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int32 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrInt(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToInt16(recv <-chan int32, send chan<- int16, mapF func(int32, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int32 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrInt16(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToInt32(recv <-chan int32, send chan<- int32, mapF func(int32, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int32 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrInt32(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToInt64(recv <-chan int32, send chan<- int64, mapF func(int32, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int32 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrInt64(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToInt8(recv <-chan int32, send chan<- int8, mapF func(int32, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int32 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrInt8(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToRune(recv <-chan int32, send chan<- rune, mapF func(int32, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int32 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrRune(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToString(recv <-chan int32, send chan<- string, mapF func(int32, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int32 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrString(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToUint(recv <-chan int32, send chan<- uint, mapF func(int32, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int32 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrUint(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToUint16(recv <-chan int32, send chan<- uint16, mapF func(int32, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int32 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrUint16(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToUint32(recv <-chan int32, send chan<- uint32, mapF func(int32, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int32 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrUint32(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToUint64(recv <-chan int32, send chan<- uint64, mapF func(int32, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int32 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrUint64(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToUint8(recv <-chan int32, send chan<- uint8, mapF func(int32, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int32 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrUint8(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToUintptr(recv <-chan int32, send chan<- uintptr, mapF func(int32, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int32 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrUintptr(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToInterface(recv <-chan int32, send chan<- interface{}, mapF func(int32, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int32 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrInterface(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToStruct(recv <-chan int32, send chan<- struct{}, mapF func(int32, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int32 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrStruct(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt32ToTimeTime(recv <-chan int32, send chan<- time.Time, mapF func(int32, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int32 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt32OrTimeTime(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToBytes(recv <-chan int64, send chan<- Bytes, mapF func(int64, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrBytes(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToBool(recv <-chan int64, send chan<- bool, mapF func(int64, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrBool(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToByte(recv <-chan int64, send chan<- byte, mapF func(int64, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrByte(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToComplex128(recv <-chan int64, send chan<- complex128, mapF func(int64, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrComplex128(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToComplex64(recv <-chan int64, send chan<- complex64, mapF func(int64, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrComplex64(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToError(recv <-chan int64, send chan<- error, mapF func(int64, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrError(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToFloat32(recv <-chan int64, send chan<- float32, mapF func(int64, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrFloat32(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToFloat64(recv <-chan int64, send chan<- float64, mapF func(int64, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrFloat64(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToInt(recv <-chan int64, send chan<- int, mapF func(int64, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrInt(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToInt16(recv <-chan int64, send chan<- int16, mapF func(int64, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrInt16(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToInt32(recv <-chan int64, send chan<- int32, mapF func(int64, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrInt32(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToInt64(recv <-chan int64, send chan<- int64, mapF func(int64, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrInt64(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToInt8(recv <-chan int64, send chan<- int8, mapF func(int64, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrInt8(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToRune(recv <-chan int64, send chan<- rune, mapF func(int64, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrRune(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToString(recv <-chan int64, send chan<- string, mapF func(int64, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrString(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToUint(recv <-chan int64, send chan<- uint, mapF func(int64, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrUint(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToUint16(recv <-chan int64, send chan<- uint16, mapF func(int64, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrUint16(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToUint32(recv <-chan int64, send chan<- uint32, mapF func(int64, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrUint32(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToUint64(recv <-chan int64, send chan<- uint64, mapF func(int64, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrUint64(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToUint8(recv <-chan int64, send chan<- uint8, mapF func(int64, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrUint8(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToUintptr(recv <-chan int64, send chan<- uintptr, mapF func(int64, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrUintptr(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToInterface(recv <-chan int64, send chan<- interface{}, mapF func(int64, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrInterface(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToStruct(recv <-chan int64, send chan<- struct{}, mapF func(int64, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrStruct(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt64ToTimeTime(recv <-chan int64, send chan<- time.Time, mapF func(int64, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt64OrTimeTime(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToBytes(recv <-chan int8, send chan<- Bytes, mapF func(int8, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int8 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrBytes(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToBool(recv <-chan int8, send chan<- bool, mapF func(int8, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int8 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrBool(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToByte(recv <-chan int8, send chan<- byte, mapF func(int8, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int8 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrByte(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToComplex128(recv <-chan int8, send chan<- complex128, mapF func(int8, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int8 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrComplex128(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToComplex64(recv <-chan int8, send chan<- complex64, mapF func(int8, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int8 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrComplex64(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToError(recv <-chan int8, send chan<- error, mapF func(int8, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int8 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrError(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToFloat32(recv <-chan int8, send chan<- float32, mapF func(int8, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int8 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrFloat32(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToFloat64(recv <-chan int8, send chan<- float64, mapF func(int8, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int8 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrFloat64(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToInt(recv <-chan int8, send chan<- int, mapF func(int8, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int8 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrInt(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToInt16(recv <-chan int8, send chan<- int16, mapF func(int8, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int8 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrInt16(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToInt32(recv <-chan int8, send chan<- int32, mapF func(int8, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int8 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrInt32(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToInt64(recv <-chan int8, send chan<- int64, mapF func(int8, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int8 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrInt64(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToInt8(recv <-chan int8, send chan<- int8, mapF func(int8, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int8 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrInt8(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToRune(recv <-chan int8, send chan<- rune, mapF func(int8, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int8 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrRune(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToString(recv <-chan int8, send chan<- string, mapF func(int8, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int8 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrString(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToUint(recv <-chan int8, send chan<- uint, mapF func(int8, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int8 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrUint(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToUint16(recv <-chan int8, send chan<- uint16, mapF func(int8, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int8 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrUint16(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToUint32(recv <-chan int8, send chan<- uint32, mapF func(int8, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int8 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrUint32(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToUint64(recv <-chan int8, send chan<- uint64, mapF func(int8, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int8 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrUint64(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToUint8(recv <-chan int8, send chan<- uint8, mapF func(int8, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int8 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrUint8(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToUintptr(recv <-chan int8, send chan<- uintptr, mapF func(int8, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int8 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrUintptr(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToInterface(recv <-chan int8, send chan<- interface{}, mapF func(int8, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int8 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrInterface(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToStruct(recv <-chan int8, send chan<- struct{}, mapF func(int8, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int8 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrStruct(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInt8ToTimeTime(recv <-chan int8, send chan<- time.Time, mapF func(int8, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int8 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInt8OrTimeTime(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToBytes(recv <-chan rune, send chan<- Bytes, mapF func(rune, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan rune = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrBytes(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToBool(recv <-chan rune, send chan<- bool, mapF func(rune, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan rune = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrBool(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToByte(recv <-chan rune, send chan<- byte, mapF func(rune, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan rune = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrByte(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToComplex128(recv <-chan rune, send chan<- complex128, mapF func(rune, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan rune = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrComplex128(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToComplex64(recv <-chan rune, send chan<- complex64, mapF func(rune, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan rune = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrComplex64(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToError(recv <-chan rune, send chan<- error, mapF func(rune, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan rune = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrError(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToFloat32(recv <-chan rune, send chan<- float32, mapF func(rune, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan rune = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrFloat32(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToFloat64(recv <-chan rune, send chan<- float64, mapF func(rune, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan rune = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrFloat64(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToInt(recv <-chan rune, send chan<- int, mapF func(rune, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan rune = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrInt(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToInt16(recv <-chan rune, send chan<- int16, mapF func(rune, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan rune = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrInt16(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToInt32(recv <-chan rune, send chan<- int32, mapF func(rune, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan rune = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrInt32(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToInt64(recv <-chan rune, send chan<- int64, mapF func(rune, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan rune = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrInt64(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToInt8(recv <-chan rune, send chan<- int8, mapF func(rune, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan rune = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrInt8(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToRune(recv <-chan rune, send chan<- rune, mapF func(rune, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan rune = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrRune(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToString(recv <-chan rune, send chan<- string, mapF func(rune, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan rune = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrString(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToUint(recv <-chan rune, send chan<- uint, mapF func(rune, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan rune = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrUint(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToUint16(recv <-chan rune, send chan<- uint16, mapF func(rune, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan rune = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrUint16(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToUint32(recv <-chan rune, send chan<- uint32, mapF func(rune, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan rune = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrUint32(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToUint64(recv <-chan rune, send chan<- uint64, mapF func(rune, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan rune = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrUint64(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToUint8(recv <-chan rune, send chan<- uint8, mapF func(rune, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan rune = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrUint8(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToUintptr(recv <-chan rune, send chan<- uintptr, mapF func(rune, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan rune = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrUintptr(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToInterface(recv <-chan rune, send chan<- interface{}, mapF func(rune, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan rune = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrInterface(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToStruct(recv <-chan rune, send chan<- struct{}, mapF func(rune, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan rune = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrStruct(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapRuneToTimeTime(recv <-chan rune, send chan<- time.Time, mapF func(rune, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan rune = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendRuneOrTimeTime(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToBytes(recv <-chan string, send chan<- Bytes, mapF func(string, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan string = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrBytes(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToBool(recv <-chan string, send chan<- bool, mapF func(string, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan string = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrBool(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToByte(recv <-chan string, send chan<- byte, mapF func(string, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan string = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrByte(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToComplex128(recv <-chan string, send chan<- complex128, mapF func(string, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan string = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrComplex128(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToComplex64(recv <-chan string, send chan<- complex64, mapF func(string, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan string = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrComplex64(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToError(recv <-chan string, send chan<- error, mapF func(string, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan string = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrError(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToFloat32(recv <-chan string, send chan<- float32, mapF func(string, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan string = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrFloat32(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToFloat64(recv <-chan string, send chan<- float64, mapF func(string, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan string = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrFloat64(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToInt(recv <-chan string, send chan<- int, mapF func(string, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan string = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrInt(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToInt16(recv <-chan string, send chan<- int16, mapF func(string, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan string = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrInt16(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToInt32(recv <-chan string, send chan<- int32, mapF func(string, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan string = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrInt32(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToInt64(recv <-chan string, send chan<- int64, mapF func(string, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan string = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrInt64(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToInt8(recv <-chan string, send chan<- int8, mapF func(string, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan string = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrInt8(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToRune(recv <-chan string, send chan<- rune, mapF func(string, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan string = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrRune(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToString(recv <-chan string, send chan<- string, mapF func(string, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan string = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrString(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToUint(recv <-chan string, send chan<- uint, mapF func(string, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan string = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrUint(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToUint16(recv <-chan string, send chan<- uint16, mapF func(string, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan string = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrUint16(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToUint32(recv <-chan string, send chan<- uint32, mapF func(string, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan string = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrUint32(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToUint64(recv <-chan string, send chan<- uint64, mapF func(string, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan string = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrUint64(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToUint8(recv <-chan string, send chan<- uint8, mapF func(string, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan string = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrUint8(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToUintptr(recv <-chan string, send chan<- uintptr, mapF func(string, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan string = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrUintptr(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToInterface(recv <-chan string, send chan<- interface{}, mapF func(string, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan string = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrInterface(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToStruct(recv <-chan string, send chan<- struct{}, mapF func(string, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan string = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrStruct(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStringToTimeTime(recv <-chan string, send chan<- time.Time, mapF func(string, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan string = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStringOrTimeTime(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToBytes(recv <-chan uint, send chan<- Bytes, mapF func(uint, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrBytes(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToBool(recv <-chan uint, send chan<- bool, mapF func(uint, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrBool(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToByte(recv <-chan uint, send chan<- byte, mapF func(uint, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrByte(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToComplex128(recv <-chan uint, send chan<- complex128, mapF func(uint, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrComplex128(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToComplex64(recv <-chan uint, send chan<- complex64, mapF func(uint, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrComplex64(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToError(recv <-chan uint, send chan<- error, mapF func(uint, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrError(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToFloat32(recv <-chan uint, send chan<- float32, mapF func(uint, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrFloat32(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToFloat64(recv <-chan uint, send chan<- float64, mapF func(uint, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrFloat64(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToInt(recv <-chan uint, send chan<- int, mapF func(uint, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrInt(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToInt16(recv <-chan uint, send chan<- int16, mapF func(uint, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrInt16(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToInt32(recv <-chan uint, send chan<- int32, mapF func(uint, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrInt32(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToInt64(recv <-chan uint, send chan<- int64, mapF func(uint, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrInt64(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToInt8(recv <-chan uint, send chan<- int8, mapF func(uint, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrInt8(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToRune(recv <-chan uint, send chan<- rune, mapF func(uint, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrRune(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToString(recv <-chan uint, send chan<- string, mapF func(uint, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrString(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToUint(recv <-chan uint, send chan<- uint, mapF func(uint, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrUint(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToUint16(recv <-chan uint, send chan<- uint16, mapF func(uint, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrUint16(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToUint32(recv <-chan uint, send chan<- uint32, mapF func(uint, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrUint32(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToUint64(recv <-chan uint, send chan<- uint64, mapF func(uint, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrUint64(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToUint8(recv <-chan uint, send chan<- uint8, mapF func(uint, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrUint8(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToUintptr(recv <-chan uint, send chan<- uintptr, mapF func(uint, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrUintptr(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToInterface(recv <-chan uint, send chan<- interface{}, mapF func(uint, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrInterface(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToStruct(recv <-chan uint, send chan<- struct{}, mapF func(uint, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrStruct(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintToTimeTime(recv <-chan uint, send chan<- time.Time, mapF func(uint, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintOrTimeTime(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToBytes(recv <-chan uint16, send chan<- Bytes, mapF func(uint16, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint16 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrBytes(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToBool(recv <-chan uint16, send chan<- bool, mapF func(uint16, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint16 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrBool(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToByte(recv <-chan uint16, send chan<- byte, mapF func(uint16, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint16 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrByte(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToComplex128(recv <-chan uint16, send chan<- complex128, mapF func(uint16, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint16 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrComplex128(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToComplex64(recv <-chan uint16, send chan<- complex64, mapF func(uint16, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint16 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrComplex64(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToError(recv <-chan uint16, send chan<- error, mapF func(uint16, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint16 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrError(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToFloat32(recv <-chan uint16, send chan<- float32, mapF func(uint16, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint16 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrFloat32(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToFloat64(recv <-chan uint16, send chan<- float64, mapF func(uint16, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint16 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrFloat64(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToInt(recv <-chan uint16, send chan<- int, mapF func(uint16, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint16 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrInt(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToInt16(recv <-chan uint16, send chan<- int16, mapF func(uint16, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint16 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrInt16(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToInt32(recv <-chan uint16, send chan<- int32, mapF func(uint16, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint16 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrInt32(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToInt64(recv <-chan uint16, send chan<- int64, mapF func(uint16, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint16 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrInt64(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToInt8(recv <-chan uint16, send chan<- int8, mapF func(uint16, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint16 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrInt8(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToRune(recv <-chan uint16, send chan<- rune, mapF func(uint16, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint16 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrRune(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToString(recv <-chan uint16, send chan<- string, mapF func(uint16, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint16 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrString(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToUint(recv <-chan uint16, send chan<- uint, mapF func(uint16, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint16 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrUint(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToUint16(recv <-chan uint16, send chan<- uint16, mapF func(uint16, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint16 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrUint16(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToUint32(recv <-chan uint16, send chan<- uint32, mapF func(uint16, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint16 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrUint32(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToUint64(recv <-chan uint16, send chan<- uint64, mapF func(uint16, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint16 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrUint64(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToUint8(recv <-chan uint16, send chan<- uint8, mapF func(uint16, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint16 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrUint8(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToUintptr(recv <-chan uint16, send chan<- uintptr, mapF func(uint16, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint16 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrUintptr(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToInterface(recv <-chan uint16, send chan<- interface{}, mapF func(uint16, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint16 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrInterface(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToStruct(recv <-chan uint16, send chan<- struct{}, mapF func(uint16, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint16 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrStruct(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint16ToTimeTime(recv <-chan uint16, send chan<- time.Time, mapF func(uint16, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint16 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint16OrTimeTime(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToBytes(recv <-chan uint32, send chan<- Bytes, mapF func(uint32, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint32 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrBytes(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToBool(recv <-chan uint32, send chan<- bool, mapF func(uint32, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint32 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrBool(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToByte(recv <-chan uint32, send chan<- byte, mapF func(uint32, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint32 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrByte(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToComplex128(recv <-chan uint32, send chan<- complex128, mapF func(uint32, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint32 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrComplex128(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToComplex64(recv <-chan uint32, send chan<- complex64, mapF func(uint32, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint32 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrComplex64(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToError(recv <-chan uint32, send chan<- error, mapF func(uint32, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint32 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrError(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToFloat32(recv <-chan uint32, send chan<- float32, mapF func(uint32, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint32 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrFloat32(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToFloat64(recv <-chan uint32, send chan<- float64, mapF func(uint32, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint32 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrFloat64(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToInt(recv <-chan uint32, send chan<- int, mapF func(uint32, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint32 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrInt(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToInt16(recv <-chan uint32, send chan<- int16, mapF func(uint32, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint32 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrInt16(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToInt32(recv <-chan uint32, send chan<- int32, mapF func(uint32, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint32 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrInt32(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToInt64(recv <-chan uint32, send chan<- int64, mapF func(uint32, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint32 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrInt64(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToInt8(recv <-chan uint32, send chan<- int8, mapF func(uint32, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint32 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrInt8(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToRune(recv <-chan uint32, send chan<- rune, mapF func(uint32, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint32 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrRune(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToString(recv <-chan uint32, send chan<- string, mapF func(uint32, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint32 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrString(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToUint(recv <-chan uint32, send chan<- uint, mapF func(uint32, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint32 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrUint(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToUint16(recv <-chan uint32, send chan<- uint16, mapF func(uint32, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint32 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrUint16(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToUint32(recv <-chan uint32, send chan<- uint32, mapF func(uint32, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint32 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrUint32(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToUint64(recv <-chan uint32, send chan<- uint64, mapF func(uint32, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint32 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrUint64(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToUint8(recv <-chan uint32, send chan<- uint8, mapF func(uint32, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint32 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrUint8(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToUintptr(recv <-chan uint32, send chan<- uintptr, mapF func(uint32, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint32 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrUintptr(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToInterface(recv <-chan uint32, send chan<- interface{}, mapF func(uint32, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint32 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrInterface(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToStruct(recv <-chan uint32, send chan<- struct{}, mapF func(uint32, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint32 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrStruct(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint32ToTimeTime(recv <-chan uint32, send chan<- time.Time, mapF func(uint32, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint32 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint32OrTimeTime(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToBytes(recv <-chan uint64, send chan<- Bytes, mapF func(uint64, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrBytes(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToBool(recv <-chan uint64, send chan<- bool, mapF func(uint64, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrBool(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToByte(recv <-chan uint64, send chan<- byte, mapF func(uint64, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrByte(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToComplex128(recv <-chan uint64, send chan<- complex128, mapF func(uint64, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrComplex128(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToComplex64(recv <-chan uint64, send chan<- complex64, mapF func(uint64, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrComplex64(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToError(recv <-chan uint64, send chan<- error, mapF func(uint64, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrError(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToFloat32(recv <-chan uint64, send chan<- float32, mapF func(uint64, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrFloat32(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToFloat64(recv <-chan uint64, send chan<- float64, mapF func(uint64, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrFloat64(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToInt(recv <-chan uint64, send chan<- int, mapF func(uint64, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrInt(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToInt16(recv <-chan uint64, send chan<- int16, mapF func(uint64, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrInt16(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToInt32(recv <-chan uint64, send chan<- int32, mapF func(uint64, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrInt32(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToInt64(recv <-chan uint64, send chan<- int64, mapF func(uint64, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrInt64(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToInt8(recv <-chan uint64, send chan<- int8, mapF func(uint64, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrInt8(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToRune(recv <-chan uint64, send chan<- rune, mapF func(uint64, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrRune(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToString(recv <-chan uint64, send chan<- string, mapF func(uint64, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrString(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToUint(recv <-chan uint64, send chan<- uint, mapF func(uint64, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrUint(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToUint16(recv <-chan uint64, send chan<- uint16, mapF func(uint64, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrUint16(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToUint32(recv <-chan uint64, send chan<- uint32, mapF func(uint64, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrUint32(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToUint64(recv <-chan uint64, send chan<- uint64, mapF func(uint64, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrUint64(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToUint8(recv <-chan uint64, send chan<- uint8, mapF func(uint64, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrUint8(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToUintptr(recv <-chan uint64, send chan<- uintptr, mapF func(uint64, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrUintptr(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToInterface(recv <-chan uint64, send chan<- interface{}, mapF func(uint64, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrInterface(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToStruct(recv <-chan uint64, send chan<- struct{}, mapF func(uint64, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrStruct(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint64ToTimeTime(recv <-chan uint64, send chan<- time.Time, mapF func(uint64, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint64OrTimeTime(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToBytes(recv <-chan uint8, send chan<- Bytes, mapF func(uint8, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint8 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrBytes(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToBool(recv <-chan uint8, send chan<- bool, mapF func(uint8, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint8 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrBool(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToByte(recv <-chan uint8, send chan<- byte, mapF func(uint8, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint8 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrByte(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToComplex128(recv <-chan uint8, send chan<- complex128, mapF func(uint8, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint8 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrComplex128(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToComplex64(recv <-chan uint8, send chan<- complex64, mapF func(uint8, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint8 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrComplex64(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToError(recv <-chan uint8, send chan<- error, mapF func(uint8, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint8 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrError(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToFloat32(recv <-chan uint8, send chan<- float32, mapF func(uint8, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint8 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrFloat32(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToFloat64(recv <-chan uint8, send chan<- float64, mapF func(uint8, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint8 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrFloat64(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToInt(recv <-chan uint8, send chan<- int, mapF func(uint8, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint8 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrInt(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToInt16(recv <-chan uint8, send chan<- int16, mapF func(uint8, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint8 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrInt16(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToInt32(recv <-chan uint8, send chan<- int32, mapF func(uint8, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint8 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrInt32(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToInt64(recv <-chan uint8, send chan<- int64, mapF func(uint8, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint8 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrInt64(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToInt8(recv <-chan uint8, send chan<- int8, mapF func(uint8, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint8 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrInt8(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToRune(recv <-chan uint8, send chan<- rune, mapF func(uint8, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint8 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrRune(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToString(recv <-chan uint8, send chan<- string, mapF func(uint8, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint8 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrString(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToUint(recv <-chan uint8, send chan<- uint, mapF func(uint8, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint8 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrUint(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToUint16(recv <-chan uint8, send chan<- uint16, mapF func(uint8, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint8 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrUint16(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToUint32(recv <-chan uint8, send chan<- uint32, mapF func(uint8, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint8 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrUint32(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToUint64(recv <-chan uint8, send chan<- uint64, mapF func(uint8, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint8 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrUint64(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToUint8(recv <-chan uint8, send chan<- uint8, mapF func(uint8, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint8 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrUint8(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToUintptr(recv <-chan uint8, send chan<- uintptr, mapF func(uint8, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint8 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrUintptr(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToInterface(recv <-chan uint8, send chan<- interface{}, mapF func(uint8, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint8 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrInterface(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToStruct(recv <-chan uint8, send chan<- struct{}, mapF func(uint8, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint8 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrStruct(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUint8ToTimeTime(recv <-chan uint8, send chan<- time.Time, mapF func(uint8, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint8 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUint8OrTimeTime(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToBytes(recv <-chan uintptr, send chan<- Bytes, mapF func(uintptr, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uintptr = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrBytes(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToBool(recv <-chan uintptr, send chan<- bool, mapF func(uintptr, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uintptr = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrBool(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToByte(recv <-chan uintptr, send chan<- byte, mapF func(uintptr, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uintptr = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrByte(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToComplex128(recv <-chan uintptr, send chan<- complex128, mapF func(uintptr, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uintptr = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrComplex128(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToComplex64(recv <-chan uintptr, send chan<- complex64, mapF func(uintptr, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uintptr = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrComplex64(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToError(recv <-chan uintptr, send chan<- error, mapF func(uintptr, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uintptr = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrError(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToFloat32(recv <-chan uintptr, send chan<- float32, mapF func(uintptr, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uintptr = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrFloat32(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToFloat64(recv <-chan uintptr, send chan<- float64, mapF func(uintptr, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uintptr = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrFloat64(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToInt(recv <-chan uintptr, send chan<- int, mapF func(uintptr, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uintptr = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrInt(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToInt16(recv <-chan uintptr, send chan<- int16, mapF func(uintptr, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uintptr = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrInt16(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToInt32(recv <-chan uintptr, send chan<- int32, mapF func(uintptr, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uintptr = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrInt32(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToInt64(recv <-chan uintptr, send chan<- int64, mapF func(uintptr, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uintptr = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrInt64(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToInt8(recv <-chan uintptr, send chan<- int8, mapF func(uintptr, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uintptr = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrInt8(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToRune(recv <-chan uintptr, send chan<- rune, mapF func(uintptr, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uintptr = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrRune(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToString(recv <-chan uintptr, send chan<- string, mapF func(uintptr, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uintptr = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrString(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToUint(recv <-chan uintptr, send chan<- uint, mapF func(uintptr, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uintptr = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrUint(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToUint16(recv <-chan uintptr, send chan<- uint16, mapF func(uintptr, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uintptr = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrUint16(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToUint32(recv <-chan uintptr, send chan<- uint32, mapF func(uintptr, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uintptr = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrUint32(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToUint64(recv <-chan uintptr, send chan<- uint64, mapF func(uintptr, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uintptr = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrUint64(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToUint8(recv <-chan uintptr, send chan<- uint8, mapF func(uintptr, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uintptr = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrUint8(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToUintptr(recv <-chan uintptr, send chan<- uintptr, mapF func(uintptr, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uintptr = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrUintptr(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToInterface(recv <-chan uintptr, send chan<- interface{}, mapF func(uintptr, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uintptr = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrInterface(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToStruct(recv <-chan uintptr, send chan<- struct{}, mapF func(uintptr, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uintptr = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrStruct(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapUintptrToTimeTime(recv <-chan uintptr, send chan<- time.Time, mapF func(uintptr, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uintptr = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendUintptrOrTimeTime(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToBytes(recv <-chan interface{}, send chan<- Bytes, mapF func(interface{}, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan interface{} = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrBytes(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToBool(recv <-chan interface{}, send chan<- bool, mapF func(interface{}, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan interface{} = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrBool(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToByte(recv <-chan interface{}, send chan<- byte, mapF func(interface{}, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan interface{} = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrByte(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToComplex128(recv <-chan interface{}, send chan<- complex128, mapF func(interface{}, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan interface{} = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrComplex128(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToComplex64(recv <-chan interface{}, send chan<- complex64, mapF func(interface{}, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan interface{} = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrComplex64(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToError(recv <-chan interface{}, send chan<- error, mapF func(interface{}, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan interface{} = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrError(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToFloat32(recv <-chan interface{}, send chan<- float32, mapF func(interface{}, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan interface{} = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrFloat32(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToFloat64(recv <-chan interface{}, send chan<- float64, mapF func(interface{}, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan interface{} = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrFloat64(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToInt(recv <-chan interface{}, send chan<- int, mapF func(interface{}, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan interface{} = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrInt(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToInt16(recv <-chan interface{}, send chan<- int16, mapF func(interface{}, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan interface{} = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrInt16(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToInt32(recv <-chan interface{}, send chan<- int32, mapF func(interface{}, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan interface{} = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrInt32(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToInt64(recv <-chan interface{}, send chan<- int64, mapF func(interface{}, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan interface{} = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrInt64(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToInt8(recv <-chan interface{}, send chan<- int8, mapF func(interface{}, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan interface{} = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrInt8(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToRune(recv <-chan interface{}, send chan<- rune, mapF func(interface{}, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan interface{} = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrRune(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToString(recv <-chan interface{}, send chan<- string, mapF func(interface{}, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan interface{} = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrString(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToUint(recv <-chan interface{}, send chan<- uint, mapF func(interface{}, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan interface{} = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrUint(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToUint16(recv <-chan interface{}, send chan<- uint16, mapF func(interface{}, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan interface{} = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrUint16(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToUint32(recv <-chan interface{}, send chan<- uint32, mapF func(interface{}, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan interface{} = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrUint32(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToUint64(recv <-chan interface{}, send chan<- uint64, mapF func(interface{}, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan interface{} = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrUint64(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToUint8(recv <-chan interface{}, send chan<- uint8, mapF func(interface{}, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan interface{} = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrUint8(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToUintptr(recv <-chan interface{}, send chan<- uintptr, mapF func(interface{}, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan interface{} = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrUintptr(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToInterface(recv <-chan interface{}, send chan<- interface{}, mapF func(interface{}, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan interface{} = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrInterface(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToStruct(recv <-chan interface{}, send chan<- struct{}, mapF func(interface{}, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan interface{} = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrStruct(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapInterfaceToTimeTime(recv <-chan interface{}, send chan<- time.Time, mapF func(interface{}, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan interface{} = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendInterfaceOrTimeTime(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToBytes(recv <-chan struct{}, send chan<- Bytes, mapF func(struct{}, bool) (Bytes, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan struct{} = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrBytes(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToBool(recv <-chan struct{}, send chan<- bool, mapF func(struct{}, bool) (bool, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan struct{} = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrBool(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToByte(recv <-chan struct{}, send chan<- byte, mapF func(struct{}, bool) (byte, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan struct{} = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrByte(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToComplex128(recv <-chan struct{}, send chan<- complex128, mapF func(struct{}, bool) (complex128, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan struct{} = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrComplex128(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToComplex64(recv <-chan struct{}, send chan<- complex64, mapF func(struct{}, bool) (complex64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan struct{} = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrComplex64(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToError(recv <-chan struct{}, send chan<- error, mapF func(struct{}, bool) (error, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan struct{} = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrError(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToFloat32(recv <-chan struct{}, send chan<- float32, mapF func(struct{}, bool) (float32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan struct{} = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrFloat32(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToFloat64(recv <-chan struct{}, send chan<- float64, mapF func(struct{}, bool) (float64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan struct{} = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrFloat64(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToInt(recv <-chan struct{}, send chan<- int, mapF func(struct{}, bool) (int, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan struct{} = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrInt(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToInt16(recv <-chan struct{}, send chan<- int16, mapF func(struct{}, bool) (int16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan struct{} = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrInt16(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToInt32(recv <-chan struct{}, send chan<- int32, mapF func(struct{}, bool) (int32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan struct{} = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrInt32(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToInt64(recv <-chan struct{}, send chan<- int64, mapF func(struct{}, bool) (int64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan struct{} = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrInt64(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToInt8(recv <-chan struct{}, send chan<- int8, mapF func(struct{}, bool) (int8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan struct{} = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrInt8(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToRune(recv <-chan struct{}, send chan<- rune, mapF func(struct{}, bool) (rune, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan struct{} = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrRune(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToString(recv <-chan struct{}, send chan<- string, mapF func(struct{}, bool) (string, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan struct{} = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrString(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToUint(recv <-chan struct{}, send chan<- uint, mapF func(struct{}, bool) (uint, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan struct{} = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrUint(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToUint16(recv <-chan struct{}, send chan<- uint16, mapF func(struct{}, bool) (uint16, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan struct{} = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrUint16(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToUint32(recv <-chan struct{}, send chan<- uint32, mapF func(struct{}, bool) (uint32, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan struct{} = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrUint32(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToUint64(recv <-chan struct{}, send chan<- uint64, mapF func(struct{}, bool) (uint64, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan struct{} = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrUint64(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToUint8(recv <-chan struct{}, send chan<- uint8, mapF func(struct{}, bool) (uint8, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan struct{} = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrUint8(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToUintptr(recv <-chan struct{}, send chan<- uintptr, mapF func(struct{}, bool) (uintptr, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan struct{} = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrUintptr(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToInterface(recv <-chan struct{}, send chan<- interface{}, mapF func(struct{}, bool) (interface{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan struct{} = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrInterface(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToStruct(recv <-chan struct{}, send chan<- struct{}, mapF func(struct{}, bool) (struct{}, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan struct{} = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrStruct(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) MapStructToTimeTime(recv <-chan struct{}, send chan<- time.Time, mapF func(struct{}, bool) (time.Time, error), onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan struct{} = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(CASE_CLOSED)
						default:
							onEvent(CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseSendStructOrTimeTime(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

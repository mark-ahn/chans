// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

import (
	"context"
	"time"

	"github.com/mark-ahn/chans/v1/core"
	"github.com/mark-ahn/syncs"
)

func MapBytesToBytes(ctx context.Context, recv <-chan Bytes, send chan<- Bytes, mapF func(Bytes, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan Bytes = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrBytes(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToBool(ctx context.Context, recv <-chan Bytes, send chan<- bool, mapF func(Bytes, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan Bytes = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrBool(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToByte(ctx context.Context, recv <-chan Bytes, send chan<- byte, mapF func(Bytes, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan Bytes = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrByte(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToComplex128(ctx context.Context, recv <-chan Bytes, send chan<- complex128, mapF func(Bytes, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan Bytes = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrComplex128(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToComplex64(ctx context.Context, recv <-chan Bytes, send chan<- complex64, mapF func(Bytes, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan Bytes = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrComplex64(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToError(ctx context.Context, recv <-chan Bytes, send chan<- error, mapF func(Bytes, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan Bytes = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrError(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToFloat32(ctx context.Context, recv <-chan Bytes, send chan<- float32, mapF func(Bytes, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan Bytes = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrFloat32(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToFloat64(ctx context.Context, recv <-chan Bytes, send chan<- float64, mapF func(Bytes, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan Bytes = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrFloat64(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToInt(ctx context.Context, recv <-chan Bytes, send chan<- int, mapF func(Bytes, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan Bytes = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrInt(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToInt16(ctx context.Context, recv <-chan Bytes, send chan<- int16, mapF func(Bytes, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan Bytes = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrInt16(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToInt32(ctx context.Context, recv <-chan Bytes, send chan<- int32, mapF func(Bytes, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan Bytes = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrInt32(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToInt64(ctx context.Context, recv <-chan Bytes, send chan<- int64, mapF func(Bytes, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan Bytes = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrInt64(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToInt8(ctx context.Context, recv <-chan Bytes, send chan<- int8, mapF func(Bytes, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan Bytes = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrInt8(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToRune(ctx context.Context, recv <-chan Bytes, send chan<- rune, mapF func(Bytes, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan Bytes = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrRune(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToString(ctx context.Context, recv <-chan Bytes, send chan<- string, mapF func(Bytes, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan Bytes = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrString(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToUint(ctx context.Context, recv <-chan Bytes, send chan<- uint, mapF func(Bytes, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan Bytes = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrUint(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToUint16(ctx context.Context, recv <-chan Bytes, send chan<- uint16, mapF func(Bytes, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan Bytes = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrUint16(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToUint32(ctx context.Context, recv <-chan Bytes, send chan<- uint32, mapF func(Bytes, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan Bytes = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrUint32(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToUint64(ctx context.Context, recv <-chan Bytes, send chan<- uint64, mapF func(Bytes, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan Bytes = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrUint64(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToUint8(ctx context.Context, recv <-chan Bytes, send chan<- uint8, mapF func(Bytes, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan Bytes = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrUint8(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToUintptr(ctx context.Context, recv <-chan Bytes, send chan<- uintptr, mapF func(Bytes, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan Bytes = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrUintptr(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToInterface(ctx context.Context, recv <-chan Bytes, send chan<- interface{}, mapF func(Bytes, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan Bytes = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrInterface(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToStruct(ctx context.Context, recv <-chan Bytes, send chan<- struct{}, mapF func(Bytes, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan Bytes = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrStruct(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBytesToTimeTime(ctx context.Context, recv <-chan Bytes, send chan<- time.Time, mapF func(Bytes, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan Bytes = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBytesOrTimeTime(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToBytes(ctx context.Context, recv <-chan bool, send chan<- Bytes, mapF func(bool, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan bool = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrBytes(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToBool(ctx context.Context, recv <-chan bool, send chan<- bool, mapF func(bool, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan bool = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrBool(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToByte(ctx context.Context, recv <-chan bool, send chan<- byte, mapF func(bool, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan bool = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrByte(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToComplex128(ctx context.Context, recv <-chan bool, send chan<- complex128, mapF func(bool, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan bool = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrComplex128(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToComplex64(ctx context.Context, recv <-chan bool, send chan<- complex64, mapF func(bool, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan bool = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrComplex64(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToError(ctx context.Context, recv <-chan bool, send chan<- error, mapF func(bool, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan bool = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrError(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToFloat32(ctx context.Context, recv <-chan bool, send chan<- float32, mapF func(bool, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan bool = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrFloat32(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToFloat64(ctx context.Context, recv <-chan bool, send chan<- float64, mapF func(bool, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan bool = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrFloat64(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToInt(ctx context.Context, recv <-chan bool, send chan<- int, mapF func(bool, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan bool = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrInt(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToInt16(ctx context.Context, recv <-chan bool, send chan<- int16, mapF func(bool, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan bool = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrInt16(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToInt32(ctx context.Context, recv <-chan bool, send chan<- int32, mapF func(bool, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan bool = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrInt32(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToInt64(ctx context.Context, recv <-chan bool, send chan<- int64, mapF func(bool, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan bool = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrInt64(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToInt8(ctx context.Context, recv <-chan bool, send chan<- int8, mapF func(bool, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan bool = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrInt8(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToRune(ctx context.Context, recv <-chan bool, send chan<- rune, mapF func(bool, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan bool = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrRune(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToString(ctx context.Context, recv <-chan bool, send chan<- string, mapF func(bool, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan bool = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrString(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToUint(ctx context.Context, recv <-chan bool, send chan<- uint, mapF func(bool, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan bool = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrUint(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToUint16(ctx context.Context, recv <-chan bool, send chan<- uint16, mapF func(bool, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan bool = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrUint16(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToUint32(ctx context.Context, recv <-chan bool, send chan<- uint32, mapF func(bool, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan bool = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrUint32(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToUint64(ctx context.Context, recv <-chan bool, send chan<- uint64, mapF func(bool, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan bool = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrUint64(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToUint8(ctx context.Context, recv <-chan bool, send chan<- uint8, mapF func(bool, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan bool = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrUint8(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToUintptr(ctx context.Context, recv <-chan bool, send chan<- uintptr, mapF func(bool, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan bool = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrUintptr(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToInterface(ctx context.Context, recv <-chan bool, send chan<- interface{}, mapF func(bool, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan bool = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrInterface(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToStruct(ctx context.Context, recv <-chan bool, send chan<- struct{}, mapF func(bool, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan bool = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrStruct(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapBoolToTimeTime(ctx context.Context, recv <-chan bool, send chan<- time.Time, mapF func(bool, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan bool = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendBoolOrTimeTime(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToBytes(ctx context.Context, recv <-chan byte, send chan<- Bytes, mapF func(byte, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan byte = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrBytes(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToBool(ctx context.Context, recv <-chan byte, send chan<- bool, mapF func(byte, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan byte = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrBool(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToByte(ctx context.Context, recv <-chan byte, send chan<- byte, mapF func(byte, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan byte = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrByte(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToComplex128(ctx context.Context, recv <-chan byte, send chan<- complex128, mapF func(byte, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan byte = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrComplex128(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToComplex64(ctx context.Context, recv <-chan byte, send chan<- complex64, mapF func(byte, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan byte = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrComplex64(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToError(ctx context.Context, recv <-chan byte, send chan<- error, mapF func(byte, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan byte = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrError(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToFloat32(ctx context.Context, recv <-chan byte, send chan<- float32, mapF func(byte, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan byte = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrFloat32(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToFloat64(ctx context.Context, recv <-chan byte, send chan<- float64, mapF func(byte, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan byte = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrFloat64(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToInt(ctx context.Context, recv <-chan byte, send chan<- int, mapF func(byte, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan byte = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrInt(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToInt16(ctx context.Context, recv <-chan byte, send chan<- int16, mapF func(byte, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan byte = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrInt16(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToInt32(ctx context.Context, recv <-chan byte, send chan<- int32, mapF func(byte, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan byte = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrInt32(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToInt64(ctx context.Context, recv <-chan byte, send chan<- int64, mapF func(byte, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan byte = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrInt64(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToInt8(ctx context.Context, recv <-chan byte, send chan<- int8, mapF func(byte, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan byte = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrInt8(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToRune(ctx context.Context, recv <-chan byte, send chan<- rune, mapF func(byte, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan byte = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrRune(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToString(ctx context.Context, recv <-chan byte, send chan<- string, mapF func(byte, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan byte = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrString(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToUint(ctx context.Context, recv <-chan byte, send chan<- uint, mapF func(byte, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan byte = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrUint(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToUint16(ctx context.Context, recv <-chan byte, send chan<- uint16, mapF func(byte, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan byte = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrUint16(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToUint32(ctx context.Context, recv <-chan byte, send chan<- uint32, mapF func(byte, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan byte = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrUint32(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToUint64(ctx context.Context, recv <-chan byte, send chan<- uint64, mapF func(byte, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan byte = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrUint64(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToUint8(ctx context.Context, recv <-chan byte, send chan<- uint8, mapF func(byte, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan byte = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrUint8(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToUintptr(ctx context.Context, recv <-chan byte, send chan<- uintptr, mapF func(byte, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan byte = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrUintptr(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToInterface(ctx context.Context, recv <-chan byte, send chan<- interface{}, mapF func(byte, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan byte = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrInterface(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToStruct(ctx context.Context, recv <-chan byte, send chan<- struct{}, mapF func(byte, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan byte = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrStruct(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapByteToTimeTime(ctx context.Context, recv <-chan byte, send chan<- time.Time, mapF func(byte, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan byte = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendByteOrTimeTime(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToBytes(ctx context.Context, recv <-chan complex128, send chan<- Bytes, mapF func(complex128, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan complex128 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrBytes(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToBool(ctx context.Context, recv <-chan complex128, send chan<- bool, mapF func(complex128, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan complex128 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrBool(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToByte(ctx context.Context, recv <-chan complex128, send chan<- byte, mapF func(complex128, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan complex128 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrByte(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToComplex128(ctx context.Context, recv <-chan complex128, send chan<- complex128, mapF func(complex128, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan complex128 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrComplex128(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToComplex64(ctx context.Context, recv <-chan complex128, send chan<- complex64, mapF func(complex128, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan complex128 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrComplex64(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToError(ctx context.Context, recv <-chan complex128, send chan<- error, mapF func(complex128, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan complex128 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrError(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToFloat32(ctx context.Context, recv <-chan complex128, send chan<- float32, mapF func(complex128, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan complex128 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrFloat32(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToFloat64(ctx context.Context, recv <-chan complex128, send chan<- float64, mapF func(complex128, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan complex128 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrFloat64(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToInt(ctx context.Context, recv <-chan complex128, send chan<- int, mapF func(complex128, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan complex128 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrInt(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToInt16(ctx context.Context, recv <-chan complex128, send chan<- int16, mapF func(complex128, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan complex128 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrInt16(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToInt32(ctx context.Context, recv <-chan complex128, send chan<- int32, mapF func(complex128, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan complex128 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrInt32(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToInt64(ctx context.Context, recv <-chan complex128, send chan<- int64, mapF func(complex128, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan complex128 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrInt64(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToInt8(ctx context.Context, recv <-chan complex128, send chan<- int8, mapF func(complex128, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan complex128 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrInt8(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToRune(ctx context.Context, recv <-chan complex128, send chan<- rune, mapF func(complex128, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan complex128 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrRune(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToString(ctx context.Context, recv <-chan complex128, send chan<- string, mapF func(complex128, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan complex128 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrString(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToUint(ctx context.Context, recv <-chan complex128, send chan<- uint, mapF func(complex128, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan complex128 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrUint(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToUint16(ctx context.Context, recv <-chan complex128, send chan<- uint16, mapF func(complex128, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan complex128 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrUint16(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToUint32(ctx context.Context, recv <-chan complex128, send chan<- uint32, mapF func(complex128, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan complex128 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrUint32(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToUint64(ctx context.Context, recv <-chan complex128, send chan<- uint64, mapF func(complex128, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan complex128 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrUint64(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToUint8(ctx context.Context, recv <-chan complex128, send chan<- uint8, mapF func(complex128, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan complex128 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrUint8(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToUintptr(ctx context.Context, recv <-chan complex128, send chan<- uintptr, mapF func(complex128, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan complex128 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrUintptr(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToInterface(ctx context.Context, recv <-chan complex128, send chan<- interface{}, mapF func(complex128, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan complex128 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrInterface(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToStruct(ctx context.Context, recv <-chan complex128, send chan<- struct{}, mapF func(complex128, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan complex128 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrStruct(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex128ToTimeTime(ctx context.Context, recv <-chan complex128, send chan<- time.Time, mapF func(complex128, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan complex128 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex128OrTimeTime(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToBytes(ctx context.Context, recv <-chan complex64, send chan<- Bytes, mapF func(complex64, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan complex64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrBytes(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToBool(ctx context.Context, recv <-chan complex64, send chan<- bool, mapF func(complex64, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan complex64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrBool(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToByte(ctx context.Context, recv <-chan complex64, send chan<- byte, mapF func(complex64, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan complex64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrByte(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToComplex128(ctx context.Context, recv <-chan complex64, send chan<- complex128, mapF func(complex64, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan complex64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrComplex128(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToComplex64(ctx context.Context, recv <-chan complex64, send chan<- complex64, mapF func(complex64, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan complex64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrComplex64(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToError(ctx context.Context, recv <-chan complex64, send chan<- error, mapF func(complex64, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan complex64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrError(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToFloat32(ctx context.Context, recv <-chan complex64, send chan<- float32, mapF func(complex64, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan complex64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrFloat32(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToFloat64(ctx context.Context, recv <-chan complex64, send chan<- float64, mapF func(complex64, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan complex64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrFloat64(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToInt(ctx context.Context, recv <-chan complex64, send chan<- int, mapF func(complex64, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan complex64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrInt(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToInt16(ctx context.Context, recv <-chan complex64, send chan<- int16, mapF func(complex64, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan complex64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrInt16(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToInt32(ctx context.Context, recv <-chan complex64, send chan<- int32, mapF func(complex64, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan complex64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrInt32(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToInt64(ctx context.Context, recv <-chan complex64, send chan<- int64, mapF func(complex64, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan complex64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrInt64(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToInt8(ctx context.Context, recv <-chan complex64, send chan<- int8, mapF func(complex64, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan complex64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrInt8(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToRune(ctx context.Context, recv <-chan complex64, send chan<- rune, mapF func(complex64, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan complex64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrRune(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToString(ctx context.Context, recv <-chan complex64, send chan<- string, mapF func(complex64, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan complex64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrString(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToUint(ctx context.Context, recv <-chan complex64, send chan<- uint, mapF func(complex64, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan complex64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrUint(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToUint16(ctx context.Context, recv <-chan complex64, send chan<- uint16, mapF func(complex64, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan complex64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrUint16(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToUint32(ctx context.Context, recv <-chan complex64, send chan<- uint32, mapF func(complex64, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan complex64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrUint32(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToUint64(ctx context.Context, recv <-chan complex64, send chan<- uint64, mapF func(complex64, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan complex64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrUint64(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToUint8(ctx context.Context, recv <-chan complex64, send chan<- uint8, mapF func(complex64, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan complex64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrUint8(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToUintptr(ctx context.Context, recv <-chan complex64, send chan<- uintptr, mapF func(complex64, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan complex64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrUintptr(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToInterface(ctx context.Context, recv <-chan complex64, send chan<- interface{}, mapF func(complex64, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan complex64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrInterface(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToStruct(ctx context.Context, recv <-chan complex64, send chan<- struct{}, mapF func(complex64, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan complex64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrStruct(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapComplex64ToTimeTime(ctx context.Context, recv <-chan complex64, send chan<- time.Time, mapF func(complex64, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan complex64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendComplex64OrTimeTime(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToBytes(ctx context.Context, recv <-chan error, send chan<- Bytes, mapF func(error, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan error = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrBytes(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToBool(ctx context.Context, recv <-chan error, send chan<- bool, mapF func(error, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan error = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrBool(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToByte(ctx context.Context, recv <-chan error, send chan<- byte, mapF func(error, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan error = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrByte(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToComplex128(ctx context.Context, recv <-chan error, send chan<- complex128, mapF func(error, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan error = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrComplex128(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToComplex64(ctx context.Context, recv <-chan error, send chan<- complex64, mapF func(error, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan error = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrComplex64(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToError(ctx context.Context, recv <-chan error, send chan<- error, mapF func(error, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan error = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrError(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToFloat32(ctx context.Context, recv <-chan error, send chan<- float32, mapF func(error, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan error = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrFloat32(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToFloat64(ctx context.Context, recv <-chan error, send chan<- float64, mapF func(error, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan error = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrFloat64(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToInt(ctx context.Context, recv <-chan error, send chan<- int, mapF func(error, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan error = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrInt(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToInt16(ctx context.Context, recv <-chan error, send chan<- int16, mapF func(error, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan error = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrInt16(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToInt32(ctx context.Context, recv <-chan error, send chan<- int32, mapF func(error, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan error = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrInt32(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToInt64(ctx context.Context, recv <-chan error, send chan<- int64, mapF func(error, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan error = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrInt64(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToInt8(ctx context.Context, recv <-chan error, send chan<- int8, mapF func(error, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan error = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrInt8(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToRune(ctx context.Context, recv <-chan error, send chan<- rune, mapF func(error, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan error = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrRune(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToString(ctx context.Context, recv <-chan error, send chan<- string, mapF func(error, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan error = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrString(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToUint(ctx context.Context, recv <-chan error, send chan<- uint, mapF func(error, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan error = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrUint(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToUint16(ctx context.Context, recv <-chan error, send chan<- uint16, mapF func(error, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan error = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrUint16(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToUint32(ctx context.Context, recv <-chan error, send chan<- uint32, mapF func(error, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan error = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrUint32(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToUint64(ctx context.Context, recv <-chan error, send chan<- uint64, mapF func(error, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan error = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrUint64(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToUint8(ctx context.Context, recv <-chan error, send chan<- uint8, mapF func(error, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan error = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrUint8(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToUintptr(ctx context.Context, recv <-chan error, send chan<- uintptr, mapF func(error, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan error = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrUintptr(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToInterface(ctx context.Context, recv <-chan error, send chan<- interface{}, mapF func(error, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan error = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrInterface(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToStruct(ctx context.Context, recv <-chan error, send chan<- struct{}, mapF func(error, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan error = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrStruct(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapErrorToTimeTime(ctx context.Context, recv <-chan error, send chan<- time.Time, mapF func(error, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan error = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendErrorOrTimeTime(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToBytes(ctx context.Context, recv <-chan float32, send chan<- Bytes, mapF func(float32, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan float32 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrBytes(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToBool(ctx context.Context, recv <-chan float32, send chan<- bool, mapF func(float32, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan float32 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrBool(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToByte(ctx context.Context, recv <-chan float32, send chan<- byte, mapF func(float32, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan float32 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrByte(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToComplex128(ctx context.Context, recv <-chan float32, send chan<- complex128, mapF func(float32, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan float32 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrComplex128(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToComplex64(ctx context.Context, recv <-chan float32, send chan<- complex64, mapF func(float32, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan float32 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrComplex64(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToError(ctx context.Context, recv <-chan float32, send chan<- error, mapF func(float32, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan float32 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrError(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToFloat32(ctx context.Context, recv <-chan float32, send chan<- float32, mapF func(float32, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan float32 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrFloat32(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToFloat64(ctx context.Context, recv <-chan float32, send chan<- float64, mapF func(float32, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan float32 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrFloat64(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToInt(ctx context.Context, recv <-chan float32, send chan<- int, mapF func(float32, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan float32 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrInt(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToInt16(ctx context.Context, recv <-chan float32, send chan<- int16, mapF func(float32, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan float32 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrInt16(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToInt32(ctx context.Context, recv <-chan float32, send chan<- int32, mapF func(float32, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan float32 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrInt32(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToInt64(ctx context.Context, recv <-chan float32, send chan<- int64, mapF func(float32, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan float32 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrInt64(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToInt8(ctx context.Context, recv <-chan float32, send chan<- int8, mapF func(float32, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan float32 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrInt8(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToRune(ctx context.Context, recv <-chan float32, send chan<- rune, mapF func(float32, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan float32 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrRune(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToString(ctx context.Context, recv <-chan float32, send chan<- string, mapF func(float32, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan float32 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrString(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToUint(ctx context.Context, recv <-chan float32, send chan<- uint, mapF func(float32, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan float32 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrUint(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToUint16(ctx context.Context, recv <-chan float32, send chan<- uint16, mapF func(float32, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan float32 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrUint16(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToUint32(ctx context.Context, recv <-chan float32, send chan<- uint32, mapF func(float32, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan float32 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrUint32(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToUint64(ctx context.Context, recv <-chan float32, send chan<- uint64, mapF func(float32, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan float32 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrUint64(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToUint8(ctx context.Context, recv <-chan float32, send chan<- uint8, mapF func(float32, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan float32 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrUint8(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToUintptr(ctx context.Context, recv <-chan float32, send chan<- uintptr, mapF func(float32, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan float32 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrUintptr(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToInterface(ctx context.Context, recv <-chan float32, send chan<- interface{}, mapF func(float32, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan float32 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrInterface(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToStruct(ctx context.Context, recv <-chan float32, send chan<- struct{}, mapF func(float32, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan float32 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrStruct(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat32ToTimeTime(ctx context.Context, recv <-chan float32, send chan<- time.Time, mapF func(float32, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan float32 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat32OrTimeTime(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToBytes(ctx context.Context, recv <-chan float64, send chan<- Bytes, mapF func(float64, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan float64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrBytes(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToBool(ctx context.Context, recv <-chan float64, send chan<- bool, mapF func(float64, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan float64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrBool(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToByte(ctx context.Context, recv <-chan float64, send chan<- byte, mapF func(float64, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan float64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrByte(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToComplex128(ctx context.Context, recv <-chan float64, send chan<- complex128, mapF func(float64, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan float64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrComplex128(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToComplex64(ctx context.Context, recv <-chan float64, send chan<- complex64, mapF func(float64, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan float64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrComplex64(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToError(ctx context.Context, recv <-chan float64, send chan<- error, mapF func(float64, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan float64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrError(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToFloat32(ctx context.Context, recv <-chan float64, send chan<- float32, mapF func(float64, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan float64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrFloat32(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToFloat64(ctx context.Context, recv <-chan float64, send chan<- float64, mapF func(float64, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan float64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrFloat64(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToInt(ctx context.Context, recv <-chan float64, send chan<- int, mapF func(float64, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan float64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrInt(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToInt16(ctx context.Context, recv <-chan float64, send chan<- int16, mapF func(float64, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan float64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrInt16(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToInt32(ctx context.Context, recv <-chan float64, send chan<- int32, mapF func(float64, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan float64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrInt32(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToInt64(ctx context.Context, recv <-chan float64, send chan<- int64, mapF func(float64, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan float64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrInt64(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToInt8(ctx context.Context, recv <-chan float64, send chan<- int8, mapF func(float64, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan float64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrInt8(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToRune(ctx context.Context, recv <-chan float64, send chan<- rune, mapF func(float64, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan float64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrRune(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToString(ctx context.Context, recv <-chan float64, send chan<- string, mapF func(float64, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan float64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrString(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToUint(ctx context.Context, recv <-chan float64, send chan<- uint, mapF func(float64, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan float64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrUint(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToUint16(ctx context.Context, recv <-chan float64, send chan<- uint16, mapF func(float64, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan float64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrUint16(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToUint32(ctx context.Context, recv <-chan float64, send chan<- uint32, mapF func(float64, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan float64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrUint32(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToUint64(ctx context.Context, recv <-chan float64, send chan<- uint64, mapF func(float64, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan float64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrUint64(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToUint8(ctx context.Context, recv <-chan float64, send chan<- uint8, mapF func(float64, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan float64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrUint8(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToUintptr(ctx context.Context, recv <-chan float64, send chan<- uintptr, mapF func(float64, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan float64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrUintptr(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToInterface(ctx context.Context, recv <-chan float64, send chan<- interface{}, mapF func(float64, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan float64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrInterface(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToStruct(ctx context.Context, recv <-chan float64, send chan<- struct{}, mapF func(float64, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan float64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrStruct(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapFloat64ToTimeTime(ctx context.Context, recv <-chan float64, send chan<- time.Time, mapF func(float64, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan float64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendFloat64OrTimeTime(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToBytes(ctx context.Context, recv <-chan int, send chan<- Bytes, mapF func(int, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrBytes(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToBool(ctx context.Context, recv <-chan int, send chan<- bool, mapF func(int, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrBool(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToByte(ctx context.Context, recv <-chan int, send chan<- byte, mapF func(int, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrByte(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToComplex128(ctx context.Context, recv <-chan int, send chan<- complex128, mapF func(int, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrComplex128(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToComplex64(ctx context.Context, recv <-chan int, send chan<- complex64, mapF func(int, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrComplex64(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToError(ctx context.Context, recv <-chan int, send chan<- error, mapF func(int, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrError(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToFloat32(ctx context.Context, recv <-chan int, send chan<- float32, mapF func(int, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrFloat32(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToFloat64(ctx context.Context, recv <-chan int, send chan<- float64, mapF func(int, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrFloat64(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToInt(ctx context.Context, recv <-chan int, send chan<- int, mapF func(int, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrInt(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToInt16(ctx context.Context, recv <-chan int, send chan<- int16, mapF func(int, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrInt16(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToInt32(ctx context.Context, recv <-chan int, send chan<- int32, mapF func(int, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrInt32(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToInt64(ctx context.Context, recv <-chan int, send chan<- int64, mapF func(int, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrInt64(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToInt8(ctx context.Context, recv <-chan int, send chan<- int8, mapF func(int, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrInt8(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToRune(ctx context.Context, recv <-chan int, send chan<- rune, mapF func(int, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrRune(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToString(ctx context.Context, recv <-chan int, send chan<- string, mapF func(int, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrString(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToUint(ctx context.Context, recv <-chan int, send chan<- uint, mapF func(int, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrUint(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToUint16(ctx context.Context, recv <-chan int, send chan<- uint16, mapF func(int, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrUint16(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToUint32(ctx context.Context, recv <-chan int, send chan<- uint32, mapF func(int, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrUint32(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToUint64(ctx context.Context, recv <-chan int, send chan<- uint64, mapF func(int, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrUint64(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToUint8(ctx context.Context, recv <-chan int, send chan<- uint8, mapF func(int, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrUint8(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToUintptr(ctx context.Context, recv <-chan int, send chan<- uintptr, mapF func(int, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrUintptr(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToInterface(ctx context.Context, recv <-chan int, send chan<- interface{}, mapF func(int, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrInterface(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToStruct(ctx context.Context, recv <-chan int, send chan<- struct{}, mapF func(int, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrStruct(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapIntToTimeTime(ctx context.Context, recv <-chan int, send chan<- time.Time, mapF func(int, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendIntOrTimeTime(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToBytes(ctx context.Context, recv <-chan int16, send chan<- Bytes, mapF func(int16, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int16 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrBytes(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToBool(ctx context.Context, recv <-chan int16, send chan<- bool, mapF func(int16, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int16 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrBool(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToByte(ctx context.Context, recv <-chan int16, send chan<- byte, mapF func(int16, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int16 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrByte(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToComplex128(ctx context.Context, recv <-chan int16, send chan<- complex128, mapF func(int16, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int16 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrComplex128(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToComplex64(ctx context.Context, recv <-chan int16, send chan<- complex64, mapF func(int16, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int16 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrComplex64(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToError(ctx context.Context, recv <-chan int16, send chan<- error, mapF func(int16, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int16 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrError(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToFloat32(ctx context.Context, recv <-chan int16, send chan<- float32, mapF func(int16, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int16 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrFloat32(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToFloat64(ctx context.Context, recv <-chan int16, send chan<- float64, mapF func(int16, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int16 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrFloat64(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToInt(ctx context.Context, recv <-chan int16, send chan<- int, mapF func(int16, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int16 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrInt(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToInt16(ctx context.Context, recv <-chan int16, send chan<- int16, mapF func(int16, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int16 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrInt16(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToInt32(ctx context.Context, recv <-chan int16, send chan<- int32, mapF func(int16, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int16 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrInt32(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToInt64(ctx context.Context, recv <-chan int16, send chan<- int64, mapF func(int16, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int16 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrInt64(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToInt8(ctx context.Context, recv <-chan int16, send chan<- int8, mapF func(int16, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int16 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrInt8(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToRune(ctx context.Context, recv <-chan int16, send chan<- rune, mapF func(int16, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int16 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrRune(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToString(ctx context.Context, recv <-chan int16, send chan<- string, mapF func(int16, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int16 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrString(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToUint(ctx context.Context, recv <-chan int16, send chan<- uint, mapF func(int16, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int16 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrUint(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToUint16(ctx context.Context, recv <-chan int16, send chan<- uint16, mapF func(int16, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int16 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrUint16(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToUint32(ctx context.Context, recv <-chan int16, send chan<- uint32, mapF func(int16, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int16 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrUint32(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToUint64(ctx context.Context, recv <-chan int16, send chan<- uint64, mapF func(int16, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int16 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrUint64(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToUint8(ctx context.Context, recv <-chan int16, send chan<- uint8, mapF func(int16, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int16 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrUint8(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToUintptr(ctx context.Context, recv <-chan int16, send chan<- uintptr, mapF func(int16, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int16 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrUintptr(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToInterface(ctx context.Context, recv <-chan int16, send chan<- interface{}, mapF func(int16, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int16 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrInterface(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToStruct(ctx context.Context, recv <-chan int16, send chan<- struct{}, mapF func(int16, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int16 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrStruct(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt16ToTimeTime(ctx context.Context, recv <-chan int16, send chan<- time.Time, mapF func(int16, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int16 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt16OrTimeTime(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToBytes(ctx context.Context, recv <-chan int32, send chan<- Bytes, mapF func(int32, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int32 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrBytes(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToBool(ctx context.Context, recv <-chan int32, send chan<- bool, mapF func(int32, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int32 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrBool(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToByte(ctx context.Context, recv <-chan int32, send chan<- byte, mapF func(int32, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int32 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrByte(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToComplex128(ctx context.Context, recv <-chan int32, send chan<- complex128, mapF func(int32, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int32 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrComplex128(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToComplex64(ctx context.Context, recv <-chan int32, send chan<- complex64, mapF func(int32, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int32 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrComplex64(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToError(ctx context.Context, recv <-chan int32, send chan<- error, mapF func(int32, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int32 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrError(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToFloat32(ctx context.Context, recv <-chan int32, send chan<- float32, mapF func(int32, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int32 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrFloat32(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToFloat64(ctx context.Context, recv <-chan int32, send chan<- float64, mapF func(int32, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int32 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrFloat64(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToInt(ctx context.Context, recv <-chan int32, send chan<- int, mapF func(int32, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int32 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrInt(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToInt16(ctx context.Context, recv <-chan int32, send chan<- int16, mapF func(int32, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int32 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrInt16(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToInt32(ctx context.Context, recv <-chan int32, send chan<- int32, mapF func(int32, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int32 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrInt32(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToInt64(ctx context.Context, recv <-chan int32, send chan<- int64, mapF func(int32, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int32 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrInt64(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToInt8(ctx context.Context, recv <-chan int32, send chan<- int8, mapF func(int32, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int32 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrInt8(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToRune(ctx context.Context, recv <-chan int32, send chan<- rune, mapF func(int32, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int32 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrRune(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToString(ctx context.Context, recv <-chan int32, send chan<- string, mapF func(int32, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int32 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrString(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToUint(ctx context.Context, recv <-chan int32, send chan<- uint, mapF func(int32, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int32 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrUint(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToUint16(ctx context.Context, recv <-chan int32, send chan<- uint16, mapF func(int32, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int32 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrUint16(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToUint32(ctx context.Context, recv <-chan int32, send chan<- uint32, mapF func(int32, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int32 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrUint32(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToUint64(ctx context.Context, recv <-chan int32, send chan<- uint64, mapF func(int32, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int32 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrUint64(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToUint8(ctx context.Context, recv <-chan int32, send chan<- uint8, mapF func(int32, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int32 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrUint8(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToUintptr(ctx context.Context, recv <-chan int32, send chan<- uintptr, mapF func(int32, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int32 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrUintptr(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToInterface(ctx context.Context, recv <-chan int32, send chan<- interface{}, mapF func(int32, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int32 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrInterface(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToStruct(ctx context.Context, recv <-chan int32, send chan<- struct{}, mapF func(int32, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int32 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrStruct(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt32ToTimeTime(ctx context.Context, recv <-chan int32, send chan<- time.Time, mapF func(int32, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int32 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt32OrTimeTime(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToBytes(ctx context.Context, recv <-chan int64, send chan<- Bytes, mapF func(int64, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrBytes(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToBool(ctx context.Context, recv <-chan int64, send chan<- bool, mapF func(int64, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrBool(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToByte(ctx context.Context, recv <-chan int64, send chan<- byte, mapF func(int64, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrByte(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToComplex128(ctx context.Context, recv <-chan int64, send chan<- complex128, mapF func(int64, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrComplex128(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToComplex64(ctx context.Context, recv <-chan int64, send chan<- complex64, mapF func(int64, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrComplex64(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToError(ctx context.Context, recv <-chan int64, send chan<- error, mapF func(int64, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrError(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToFloat32(ctx context.Context, recv <-chan int64, send chan<- float32, mapF func(int64, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrFloat32(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToFloat64(ctx context.Context, recv <-chan int64, send chan<- float64, mapF func(int64, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrFloat64(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToInt(ctx context.Context, recv <-chan int64, send chan<- int, mapF func(int64, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrInt(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToInt16(ctx context.Context, recv <-chan int64, send chan<- int16, mapF func(int64, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrInt16(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToInt32(ctx context.Context, recv <-chan int64, send chan<- int32, mapF func(int64, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrInt32(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToInt64(ctx context.Context, recv <-chan int64, send chan<- int64, mapF func(int64, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrInt64(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToInt8(ctx context.Context, recv <-chan int64, send chan<- int8, mapF func(int64, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrInt8(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToRune(ctx context.Context, recv <-chan int64, send chan<- rune, mapF func(int64, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrRune(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToString(ctx context.Context, recv <-chan int64, send chan<- string, mapF func(int64, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrString(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToUint(ctx context.Context, recv <-chan int64, send chan<- uint, mapF func(int64, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrUint(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToUint16(ctx context.Context, recv <-chan int64, send chan<- uint16, mapF func(int64, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrUint16(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToUint32(ctx context.Context, recv <-chan int64, send chan<- uint32, mapF func(int64, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrUint32(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToUint64(ctx context.Context, recv <-chan int64, send chan<- uint64, mapF func(int64, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrUint64(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToUint8(ctx context.Context, recv <-chan int64, send chan<- uint8, mapF func(int64, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrUint8(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToUintptr(ctx context.Context, recv <-chan int64, send chan<- uintptr, mapF func(int64, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrUintptr(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToInterface(ctx context.Context, recv <-chan int64, send chan<- interface{}, mapF func(int64, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrInterface(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToStruct(ctx context.Context, recv <-chan int64, send chan<- struct{}, mapF func(int64, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrStruct(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt64ToTimeTime(ctx context.Context, recv <-chan int64, send chan<- time.Time, mapF func(int64, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt64OrTimeTime(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToBytes(ctx context.Context, recv <-chan int8, send chan<- Bytes, mapF func(int8, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int8 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrBytes(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToBool(ctx context.Context, recv <-chan int8, send chan<- bool, mapF func(int8, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int8 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrBool(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToByte(ctx context.Context, recv <-chan int8, send chan<- byte, mapF func(int8, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int8 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrByte(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToComplex128(ctx context.Context, recv <-chan int8, send chan<- complex128, mapF func(int8, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int8 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrComplex128(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToComplex64(ctx context.Context, recv <-chan int8, send chan<- complex64, mapF func(int8, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int8 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrComplex64(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToError(ctx context.Context, recv <-chan int8, send chan<- error, mapF func(int8, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int8 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrError(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToFloat32(ctx context.Context, recv <-chan int8, send chan<- float32, mapF func(int8, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int8 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrFloat32(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToFloat64(ctx context.Context, recv <-chan int8, send chan<- float64, mapF func(int8, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int8 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrFloat64(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToInt(ctx context.Context, recv <-chan int8, send chan<- int, mapF func(int8, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int8 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrInt(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToInt16(ctx context.Context, recv <-chan int8, send chan<- int16, mapF func(int8, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int8 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrInt16(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToInt32(ctx context.Context, recv <-chan int8, send chan<- int32, mapF func(int8, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int8 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrInt32(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToInt64(ctx context.Context, recv <-chan int8, send chan<- int64, mapF func(int8, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int8 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrInt64(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToInt8(ctx context.Context, recv <-chan int8, send chan<- int8, mapF func(int8, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int8 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrInt8(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToRune(ctx context.Context, recv <-chan int8, send chan<- rune, mapF func(int8, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int8 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrRune(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToString(ctx context.Context, recv <-chan int8, send chan<- string, mapF func(int8, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int8 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrString(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToUint(ctx context.Context, recv <-chan int8, send chan<- uint, mapF func(int8, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int8 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrUint(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToUint16(ctx context.Context, recv <-chan int8, send chan<- uint16, mapF func(int8, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int8 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrUint16(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToUint32(ctx context.Context, recv <-chan int8, send chan<- uint32, mapF func(int8, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int8 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrUint32(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToUint64(ctx context.Context, recv <-chan int8, send chan<- uint64, mapF func(int8, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int8 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrUint64(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToUint8(ctx context.Context, recv <-chan int8, send chan<- uint8, mapF func(int8, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int8 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrUint8(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToUintptr(ctx context.Context, recv <-chan int8, send chan<- uintptr, mapF func(int8, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int8 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrUintptr(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToInterface(ctx context.Context, recv <-chan int8, send chan<- interface{}, mapF func(int8, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int8 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrInterface(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToStruct(ctx context.Context, recv <-chan int8, send chan<- struct{}, mapF func(int8, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int8 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrStruct(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInt8ToTimeTime(ctx context.Context, recv <-chan int8, send chan<- time.Time, mapF func(int8, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int8 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInt8OrTimeTime(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToBytes(ctx context.Context, recv <-chan rune, send chan<- Bytes, mapF func(rune, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan rune = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrBytes(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToBool(ctx context.Context, recv <-chan rune, send chan<- bool, mapF func(rune, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan rune = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrBool(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToByte(ctx context.Context, recv <-chan rune, send chan<- byte, mapF func(rune, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan rune = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrByte(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToComplex128(ctx context.Context, recv <-chan rune, send chan<- complex128, mapF func(rune, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan rune = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrComplex128(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToComplex64(ctx context.Context, recv <-chan rune, send chan<- complex64, mapF func(rune, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan rune = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrComplex64(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToError(ctx context.Context, recv <-chan rune, send chan<- error, mapF func(rune, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan rune = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrError(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToFloat32(ctx context.Context, recv <-chan rune, send chan<- float32, mapF func(rune, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan rune = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrFloat32(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToFloat64(ctx context.Context, recv <-chan rune, send chan<- float64, mapF func(rune, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan rune = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrFloat64(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToInt(ctx context.Context, recv <-chan rune, send chan<- int, mapF func(rune, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan rune = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrInt(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToInt16(ctx context.Context, recv <-chan rune, send chan<- int16, mapF func(rune, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan rune = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrInt16(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToInt32(ctx context.Context, recv <-chan rune, send chan<- int32, mapF func(rune, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan rune = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrInt32(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToInt64(ctx context.Context, recv <-chan rune, send chan<- int64, mapF func(rune, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan rune = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrInt64(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToInt8(ctx context.Context, recv <-chan rune, send chan<- int8, mapF func(rune, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan rune = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrInt8(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToRune(ctx context.Context, recv <-chan rune, send chan<- rune, mapF func(rune, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan rune = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrRune(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToString(ctx context.Context, recv <-chan rune, send chan<- string, mapF func(rune, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan rune = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrString(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToUint(ctx context.Context, recv <-chan rune, send chan<- uint, mapF func(rune, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan rune = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrUint(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToUint16(ctx context.Context, recv <-chan rune, send chan<- uint16, mapF func(rune, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan rune = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrUint16(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToUint32(ctx context.Context, recv <-chan rune, send chan<- uint32, mapF func(rune, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan rune = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrUint32(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToUint64(ctx context.Context, recv <-chan rune, send chan<- uint64, mapF func(rune, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan rune = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrUint64(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToUint8(ctx context.Context, recv <-chan rune, send chan<- uint8, mapF func(rune, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan rune = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrUint8(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToUintptr(ctx context.Context, recv <-chan rune, send chan<- uintptr, mapF func(rune, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan rune = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrUintptr(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToInterface(ctx context.Context, recv <-chan rune, send chan<- interface{}, mapF func(rune, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan rune = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrInterface(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToStruct(ctx context.Context, recv <-chan rune, send chan<- struct{}, mapF func(rune, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan rune = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrStruct(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapRuneToTimeTime(ctx context.Context, recv <-chan rune, send chan<- time.Time, mapF func(rune, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan rune = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendRuneOrTimeTime(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToBytes(ctx context.Context, recv <-chan string, send chan<- Bytes, mapF func(string, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan string = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrBytes(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToBool(ctx context.Context, recv <-chan string, send chan<- bool, mapF func(string, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan string = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrBool(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToByte(ctx context.Context, recv <-chan string, send chan<- byte, mapF func(string, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan string = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrByte(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToComplex128(ctx context.Context, recv <-chan string, send chan<- complex128, mapF func(string, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan string = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrComplex128(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToComplex64(ctx context.Context, recv <-chan string, send chan<- complex64, mapF func(string, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan string = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrComplex64(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToError(ctx context.Context, recv <-chan string, send chan<- error, mapF func(string, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan string = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrError(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToFloat32(ctx context.Context, recv <-chan string, send chan<- float32, mapF func(string, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan string = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrFloat32(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToFloat64(ctx context.Context, recv <-chan string, send chan<- float64, mapF func(string, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan string = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrFloat64(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToInt(ctx context.Context, recv <-chan string, send chan<- int, mapF func(string, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan string = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrInt(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToInt16(ctx context.Context, recv <-chan string, send chan<- int16, mapF func(string, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan string = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrInt16(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToInt32(ctx context.Context, recv <-chan string, send chan<- int32, mapF func(string, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan string = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrInt32(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToInt64(ctx context.Context, recv <-chan string, send chan<- int64, mapF func(string, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan string = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrInt64(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToInt8(ctx context.Context, recv <-chan string, send chan<- int8, mapF func(string, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan string = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrInt8(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToRune(ctx context.Context, recv <-chan string, send chan<- rune, mapF func(string, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan string = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrRune(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToString(ctx context.Context, recv <-chan string, send chan<- string, mapF func(string, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan string = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrString(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToUint(ctx context.Context, recv <-chan string, send chan<- uint, mapF func(string, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan string = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrUint(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToUint16(ctx context.Context, recv <-chan string, send chan<- uint16, mapF func(string, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan string = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrUint16(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToUint32(ctx context.Context, recv <-chan string, send chan<- uint32, mapF func(string, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan string = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrUint32(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToUint64(ctx context.Context, recv <-chan string, send chan<- uint64, mapF func(string, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan string = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrUint64(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToUint8(ctx context.Context, recv <-chan string, send chan<- uint8, mapF func(string, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan string = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrUint8(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToUintptr(ctx context.Context, recv <-chan string, send chan<- uintptr, mapF func(string, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan string = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrUintptr(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToInterface(ctx context.Context, recv <-chan string, send chan<- interface{}, mapF func(string, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan string = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrInterface(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToStruct(ctx context.Context, recv <-chan string, send chan<- struct{}, mapF func(string, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan string = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrStruct(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStringToTimeTime(ctx context.Context, recv <-chan string, send chan<- time.Time, mapF func(string, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan string = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStringOrTimeTime(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToBytes(ctx context.Context, recv <-chan uint, send chan<- Bytes, mapF func(uint, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrBytes(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToBool(ctx context.Context, recv <-chan uint, send chan<- bool, mapF func(uint, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrBool(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToByte(ctx context.Context, recv <-chan uint, send chan<- byte, mapF func(uint, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrByte(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToComplex128(ctx context.Context, recv <-chan uint, send chan<- complex128, mapF func(uint, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrComplex128(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToComplex64(ctx context.Context, recv <-chan uint, send chan<- complex64, mapF func(uint, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrComplex64(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToError(ctx context.Context, recv <-chan uint, send chan<- error, mapF func(uint, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrError(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToFloat32(ctx context.Context, recv <-chan uint, send chan<- float32, mapF func(uint, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrFloat32(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToFloat64(ctx context.Context, recv <-chan uint, send chan<- float64, mapF func(uint, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrFloat64(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToInt(ctx context.Context, recv <-chan uint, send chan<- int, mapF func(uint, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrInt(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToInt16(ctx context.Context, recv <-chan uint, send chan<- int16, mapF func(uint, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrInt16(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToInt32(ctx context.Context, recv <-chan uint, send chan<- int32, mapF func(uint, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrInt32(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToInt64(ctx context.Context, recv <-chan uint, send chan<- int64, mapF func(uint, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrInt64(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToInt8(ctx context.Context, recv <-chan uint, send chan<- int8, mapF func(uint, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrInt8(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToRune(ctx context.Context, recv <-chan uint, send chan<- rune, mapF func(uint, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrRune(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToString(ctx context.Context, recv <-chan uint, send chan<- string, mapF func(uint, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrString(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToUint(ctx context.Context, recv <-chan uint, send chan<- uint, mapF func(uint, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrUint(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToUint16(ctx context.Context, recv <-chan uint, send chan<- uint16, mapF func(uint, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrUint16(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToUint32(ctx context.Context, recv <-chan uint, send chan<- uint32, mapF func(uint, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrUint32(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToUint64(ctx context.Context, recv <-chan uint, send chan<- uint64, mapF func(uint, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrUint64(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToUint8(ctx context.Context, recv <-chan uint, send chan<- uint8, mapF func(uint, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrUint8(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToUintptr(ctx context.Context, recv <-chan uint, send chan<- uintptr, mapF func(uint, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrUintptr(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToInterface(ctx context.Context, recv <-chan uint, send chan<- interface{}, mapF func(uint, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrInterface(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToStruct(ctx context.Context, recv <-chan uint, send chan<- struct{}, mapF func(uint, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrStruct(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintToTimeTime(ctx context.Context, recv <-chan uint, send chan<- time.Time, mapF func(uint, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintOrTimeTime(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToBytes(ctx context.Context, recv <-chan uint16, send chan<- Bytes, mapF func(uint16, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint16 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrBytes(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToBool(ctx context.Context, recv <-chan uint16, send chan<- bool, mapF func(uint16, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint16 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrBool(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToByte(ctx context.Context, recv <-chan uint16, send chan<- byte, mapF func(uint16, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint16 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrByte(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToComplex128(ctx context.Context, recv <-chan uint16, send chan<- complex128, mapF func(uint16, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint16 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrComplex128(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToComplex64(ctx context.Context, recv <-chan uint16, send chan<- complex64, mapF func(uint16, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint16 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrComplex64(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToError(ctx context.Context, recv <-chan uint16, send chan<- error, mapF func(uint16, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint16 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrError(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToFloat32(ctx context.Context, recv <-chan uint16, send chan<- float32, mapF func(uint16, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint16 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrFloat32(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToFloat64(ctx context.Context, recv <-chan uint16, send chan<- float64, mapF func(uint16, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint16 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrFloat64(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToInt(ctx context.Context, recv <-chan uint16, send chan<- int, mapF func(uint16, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint16 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrInt(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToInt16(ctx context.Context, recv <-chan uint16, send chan<- int16, mapF func(uint16, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint16 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrInt16(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToInt32(ctx context.Context, recv <-chan uint16, send chan<- int32, mapF func(uint16, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint16 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrInt32(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToInt64(ctx context.Context, recv <-chan uint16, send chan<- int64, mapF func(uint16, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint16 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrInt64(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToInt8(ctx context.Context, recv <-chan uint16, send chan<- int8, mapF func(uint16, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint16 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrInt8(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToRune(ctx context.Context, recv <-chan uint16, send chan<- rune, mapF func(uint16, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint16 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrRune(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToString(ctx context.Context, recv <-chan uint16, send chan<- string, mapF func(uint16, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint16 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrString(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToUint(ctx context.Context, recv <-chan uint16, send chan<- uint, mapF func(uint16, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint16 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrUint(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToUint16(ctx context.Context, recv <-chan uint16, send chan<- uint16, mapF func(uint16, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint16 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrUint16(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToUint32(ctx context.Context, recv <-chan uint16, send chan<- uint32, mapF func(uint16, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint16 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrUint32(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToUint64(ctx context.Context, recv <-chan uint16, send chan<- uint64, mapF func(uint16, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint16 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrUint64(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToUint8(ctx context.Context, recv <-chan uint16, send chan<- uint8, mapF func(uint16, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint16 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrUint8(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToUintptr(ctx context.Context, recv <-chan uint16, send chan<- uintptr, mapF func(uint16, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint16 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrUintptr(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToInterface(ctx context.Context, recv <-chan uint16, send chan<- interface{}, mapF func(uint16, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint16 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrInterface(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToStruct(ctx context.Context, recv <-chan uint16, send chan<- struct{}, mapF func(uint16, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint16 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrStruct(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint16ToTimeTime(ctx context.Context, recv <-chan uint16, send chan<- time.Time, mapF func(uint16, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint16 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint16OrTimeTime(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToBytes(ctx context.Context, recv <-chan uint32, send chan<- Bytes, mapF func(uint32, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint32 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrBytes(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToBool(ctx context.Context, recv <-chan uint32, send chan<- bool, mapF func(uint32, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint32 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrBool(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToByte(ctx context.Context, recv <-chan uint32, send chan<- byte, mapF func(uint32, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint32 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrByte(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToComplex128(ctx context.Context, recv <-chan uint32, send chan<- complex128, mapF func(uint32, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint32 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrComplex128(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToComplex64(ctx context.Context, recv <-chan uint32, send chan<- complex64, mapF func(uint32, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint32 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrComplex64(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToError(ctx context.Context, recv <-chan uint32, send chan<- error, mapF func(uint32, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint32 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrError(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToFloat32(ctx context.Context, recv <-chan uint32, send chan<- float32, mapF func(uint32, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint32 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrFloat32(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToFloat64(ctx context.Context, recv <-chan uint32, send chan<- float64, mapF func(uint32, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint32 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrFloat64(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToInt(ctx context.Context, recv <-chan uint32, send chan<- int, mapF func(uint32, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint32 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrInt(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToInt16(ctx context.Context, recv <-chan uint32, send chan<- int16, mapF func(uint32, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint32 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrInt16(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToInt32(ctx context.Context, recv <-chan uint32, send chan<- int32, mapF func(uint32, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint32 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrInt32(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToInt64(ctx context.Context, recv <-chan uint32, send chan<- int64, mapF func(uint32, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint32 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrInt64(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToInt8(ctx context.Context, recv <-chan uint32, send chan<- int8, mapF func(uint32, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint32 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrInt8(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToRune(ctx context.Context, recv <-chan uint32, send chan<- rune, mapF func(uint32, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint32 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrRune(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToString(ctx context.Context, recv <-chan uint32, send chan<- string, mapF func(uint32, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint32 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrString(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToUint(ctx context.Context, recv <-chan uint32, send chan<- uint, mapF func(uint32, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint32 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrUint(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToUint16(ctx context.Context, recv <-chan uint32, send chan<- uint16, mapF func(uint32, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint32 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrUint16(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToUint32(ctx context.Context, recv <-chan uint32, send chan<- uint32, mapF func(uint32, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint32 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrUint32(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToUint64(ctx context.Context, recv <-chan uint32, send chan<- uint64, mapF func(uint32, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint32 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrUint64(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToUint8(ctx context.Context, recv <-chan uint32, send chan<- uint8, mapF func(uint32, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint32 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrUint8(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToUintptr(ctx context.Context, recv <-chan uint32, send chan<- uintptr, mapF func(uint32, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint32 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrUintptr(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToInterface(ctx context.Context, recv <-chan uint32, send chan<- interface{}, mapF func(uint32, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint32 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrInterface(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToStruct(ctx context.Context, recv <-chan uint32, send chan<- struct{}, mapF func(uint32, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint32 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrStruct(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint32ToTimeTime(ctx context.Context, recv <-chan uint32, send chan<- time.Time, mapF func(uint32, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint32 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint32OrTimeTime(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToBytes(ctx context.Context, recv <-chan uint64, send chan<- Bytes, mapF func(uint64, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrBytes(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToBool(ctx context.Context, recv <-chan uint64, send chan<- bool, mapF func(uint64, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrBool(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToByte(ctx context.Context, recv <-chan uint64, send chan<- byte, mapF func(uint64, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrByte(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToComplex128(ctx context.Context, recv <-chan uint64, send chan<- complex128, mapF func(uint64, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrComplex128(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToComplex64(ctx context.Context, recv <-chan uint64, send chan<- complex64, mapF func(uint64, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrComplex64(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToError(ctx context.Context, recv <-chan uint64, send chan<- error, mapF func(uint64, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrError(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToFloat32(ctx context.Context, recv <-chan uint64, send chan<- float32, mapF func(uint64, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrFloat32(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToFloat64(ctx context.Context, recv <-chan uint64, send chan<- float64, mapF func(uint64, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrFloat64(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToInt(ctx context.Context, recv <-chan uint64, send chan<- int, mapF func(uint64, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrInt(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToInt16(ctx context.Context, recv <-chan uint64, send chan<- int16, mapF func(uint64, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrInt16(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToInt32(ctx context.Context, recv <-chan uint64, send chan<- int32, mapF func(uint64, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrInt32(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToInt64(ctx context.Context, recv <-chan uint64, send chan<- int64, mapF func(uint64, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrInt64(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToInt8(ctx context.Context, recv <-chan uint64, send chan<- int8, mapF func(uint64, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrInt8(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToRune(ctx context.Context, recv <-chan uint64, send chan<- rune, mapF func(uint64, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrRune(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToString(ctx context.Context, recv <-chan uint64, send chan<- string, mapF func(uint64, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrString(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToUint(ctx context.Context, recv <-chan uint64, send chan<- uint, mapF func(uint64, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrUint(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToUint16(ctx context.Context, recv <-chan uint64, send chan<- uint16, mapF func(uint64, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrUint16(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToUint32(ctx context.Context, recv <-chan uint64, send chan<- uint32, mapF func(uint64, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrUint32(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToUint64(ctx context.Context, recv <-chan uint64, send chan<- uint64, mapF func(uint64, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrUint64(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToUint8(ctx context.Context, recv <-chan uint64, send chan<- uint8, mapF func(uint64, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrUint8(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToUintptr(ctx context.Context, recv <-chan uint64, send chan<- uintptr, mapF func(uint64, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrUintptr(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToInterface(ctx context.Context, recv <-chan uint64, send chan<- interface{}, mapF func(uint64, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrInterface(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToStruct(ctx context.Context, recv <-chan uint64, send chan<- struct{}, mapF func(uint64, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrStruct(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint64ToTimeTime(ctx context.Context, recv <-chan uint64, send chan<- time.Time, mapF func(uint64, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint64OrTimeTime(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToBytes(ctx context.Context, recv <-chan uint8, send chan<- Bytes, mapF func(uint8, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint8 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrBytes(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToBool(ctx context.Context, recv <-chan uint8, send chan<- bool, mapF func(uint8, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint8 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrBool(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToByte(ctx context.Context, recv <-chan uint8, send chan<- byte, mapF func(uint8, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint8 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrByte(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToComplex128(ctx context.Context, recv <-chan uint8, send chan<- complex128, mapF func(uint8, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint8 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrComplex128(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToComplex64(ctx context.Context, recv <-chan uint8, send chan<- complex64, mapF func(uint8, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint8 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrComplex64(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToError(ctx context.Context, recv <-chan uint8, send chan<- error, mapF func(uint8, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint8 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrError(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToFloat32(ctx context.Context, recv <-chan uint8, send chan<- float32, mapF func(uint8, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint8 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrFloat32(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToFloat64(ctx context.Context, recv <-chan uint8, send chan<- float64, mapF func(uint8, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint8 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrFloat64(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToInt(ctx context.Context, recv <-chan uint8, send chan<- int, mapF func(uint8, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint8 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrInt(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToInt16(ctx context.Context, recv <-chan uint8, send chan<- int16, mapF func(uint8, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint8 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrInt16(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToInt32(ctx context.Context, recv <-chan uint8, send chan<- int32, mapF func(uint8, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint8 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrInt32(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToInt64(ctx context.Context, recv <-chan uint8, send chan<- int64, mapF func(uint8, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint8 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrInt64(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToInt8(ctx context.Context, recv <-chan uint8, send chan<- int8, mapF func(uint8, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint8 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrInt8(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToRune(ctx context.Context, recv <-chan uint8, send chan<- rune, mapF func(uint8, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint8 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrRune(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToString(ctx context.Context, recv <-chan uint8, send chan<- string, mapF func(uint8, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint8 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrString(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToUint(ctx context.Context, recv <-chan uint8, send chan<- uint, mapF func(uint8, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint8 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrUint(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToUint16(ctx context.Context, recv <-chan uint8, send chan<- uint16, mapF func(uint8, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint8 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrUint16(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToUint32(ctx context.Context, recv <-chan uint8, send chan<- uint32, mapF func(uint8, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint8 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrUint32(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToUint64(ctx context.Context, recv <-chan uint8, send chan<- uint64, mapF func(uint8, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint8 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrUint64(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToUint8(ctx context.Context, recv <-chan uint8, send chan<- uint8, mapF func(uint8, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint8 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrUint8(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToUintptr(ctx context.Context, recv <-chan uint8, send chan<- uintptr, mapF func(uint8, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint8 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrUintptr(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToInterface(ctx context.Context, recv <-chan uint8, send chan<- interface{}, mapF func(uint8, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint8 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrInterface(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToStruct(ctx context.Context, recv <-chan uint8, send chan<- struct{}, mapF func(uint8, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint8 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrStruct(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUint8ToTimeTime(ctx context.Context, recv <-chan uint8, send chan<- time.Time, mapF func(uint8, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint8 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUint8OrTimeTime(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToBytes(ctx context.Context, recv <-chan uintptr, send chan<- Bytes, mapF func(uintptr, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uintptr = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrBytes(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToBool(ctx context.Context, recv <-chan uintptr, send chan<- bool, mapF func(uintptr, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uintptr = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrBool(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToByte(ctx context.Context, recv <-chan uintptr, send chan<- byte, mapF func(uintptr, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uintptr = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrByte(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToComplex128(ctx context.Context, recv <-chan uintptr, send chan<- complex128, mapF func(uintptr, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uintptr = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrComplex128(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToComplex64(ctx context.Context, recv <-chan uintptr, send chan<- complex64, mapF func(uintptr, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uintptr = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrComplex64(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToError(ctx context.Context, recv <-chan uintptr, send chan<- error, mapF func(uintptr, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uintptr = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrError(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToFloat32(ctx context.Context, recv <-chan uintptr, send chan<- float32, mapF func(uintptr, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uintptr = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrFloat32(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToFloat64(ctx context.Context, recv <-chan uintptr, send chan<- float64, mapF func(uintptr, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uintptr = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrFloat64(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToInt(ctx context.Context, recv <-chan uintptr, send chan<- int, mapF func(uintptr, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uintptr = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrInt(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToInt16(ctx context.Context, recv <-chan uintptr, send chan<- int16, mapF func(uintptr, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uintptr = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrInt16(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToInt32(ctx context.Context, recv <-chan uintptr, send chan<- int32, mapF func(uintptr, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uintptr = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrInt32(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToInt64(ctx context.Context, recv <-chan uintptr, send chan<- int64, mapF func(uintptr, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uintptr = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrInt64(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToInt8(ctx context.Context, recv <-chan uintptr, send chan<- int8, mapF func(uintptr, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uintptr = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrInt8(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToRune(ctx context.Context, recv <-chan uintptr, send chan<- rune, mapF func(uintptr, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uintptr = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrRune(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToString(ctx context.Context, recv <-chan uintptr, send chan<- string, mapF func(uintptr, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uintptr = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrString(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToUint(ctx context.Context, recv <-chan uintptr, send chan<- uint, mapF func(uintptr, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uintptr = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrUint(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToUint16(ctx context.Context, recv <-chan uintptr, send chan<- uint16, mapF func(uintptr, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uintptr = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrUint16(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToUint32(ctx context.Context, recv <-chan uintptr, send chan<- uint32, mapF func(uintptr, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uintptr = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrUint32(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToUint64(ctx context.Context, recv <-chan uintptr, send chan<- uint64, mapF func(uintptr, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uintptr = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrUint64(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToUint8(ctx context.Context, recv <-chan uintptr, send chan<- uint8, mapF func(uintptr, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uintptr = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrUint8(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToUintptr(ctx context.Context, recv <-chan uintptr, send chan<- uintptr, mapF func(uintptr, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uintptr = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrUintptr(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToInterface(ctx context.Context, recv <-chan uintptr, send chan<- interface{}, mapF func(uintptr, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uintptr = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrInterface(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToStruct(ctx context.Context, recv <-chan uintptr, send chan<- struct{}, mapF func(uintptr, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uintptr = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrStruct(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapUintptrToTimeTime(ctx context.Context, recv <-chan uintptr, send chan<- time.Time, mapF func(uintptr, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uintptr = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendUintptrOrTimeTime(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToBytes(ctx context.Context, recv <-chan interface{}, send chan<- Bytes, mapF func(interface{}, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan interface{} = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrBytes(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToBool(ctx context.Context, recv <-chan interface{}, send chan<- bool, mapF func(interface{}, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan interface{} = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrBool(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToByte(ctx context.Context, recv <-chan interface{}, send chan<- byte, mapF func(interface{}, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan interface{} = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrByte(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToComplex128(ctx context.Context, recv <-chan interface{}, send chan<- complex128, mapF func(interface{}, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan interface{} = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrComplex128(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToComplex64(ctx context.Context, recv <-chan interface{}, send chan<- complex64, mapF func(interface{}, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan interface{} = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrComplex64(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToError(ctx context.Context, recv <-chan interface{}, send chan<- error, mapF func(interface{}, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan interface{} = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrError(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToFloat32(ctx context.Context, recv <-chan interface{}, send chan<- float32, mapF func(interface{}, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan interface{} = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrFloat32(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToFloat64(ctx context.Context, recv <-chan interface{}, send chan<- float64, mapF func(interface{}, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan interface{} = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrFloat64(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToInt(ctx context.Context, recv <-chan interface{}, send chan<- int, mapF func(interface{}, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan interface{} = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrInt(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToInt16(ctx context.Context, recv <-chan interface{}, send chan<- int16, mapF func(interface{}, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan interface{} = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrInt16(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToInt32(ctx context.Context, recv <-chan interface{}, send chan<- int32, mapF func(interface{}, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan interface{} = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrInt32(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToInt64(ctx context.Context, recv <-chan interface{}, send chan<- int64, mapF func(interface{}, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan interface{} = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrInt64(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToInt8(ctx context.Context, recv <-chan interface{}, send chan<- int8, mapF func(interface{}, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan interface{} = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrInt8(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToRune(ctx context.Context, recv <-chan interface{}, send chan<- rune, mapF func(interface{}, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan interface{} = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrRune(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToString(ctx context.Context, recv <-chan interface{}, send chan<- string, mapF func(interface{}, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan interface{} = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrString(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToUint(ctx context.Context, recv <-chan interface{}, send chan<- uint, mapF func(interface{}, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan interface{} = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrUint(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToUint16(ctx context.Context, recv <-chan interface{}, send chan<- uint16, mapF func(interface{}, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan interface{} = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrUint16(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToUint32(ctx context.Context, recv <-chan interface{}, send chan<- uint32, mapF func(interface{}, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan interface{} = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrUint32(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToUint64(ctx context.Context, recv <-chan interface{}, send chan<- uint64, mapF func(interface{}, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan interface{} = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrUint64(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToUint8(ctx context.Context, recv <-chan interface{}, send chan<- uint8, mapF func(interface{}, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan interface{} = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrUint8(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToUintptr(ctx context.Context, recv <-chan interface{}, send chan<- uintptr, mapF func(interface{}, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan interface{} = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrUintptr(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToInterface(ctx context.Context, recv <-chan interface{}, send chan<- interface{}, mapF func(interface{}, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan interface{} = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrInterface(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToStruct(ctx context.Context, recv <-chan interface{}, send chan<- struct{}, mapF func(interface{}, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan interface{} = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrStruct(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapInterfaceToTimeTime(ctx context.Context, recv <-chan interface{}, send chan<- time.Time, mapF func(interface{}, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan interface{} = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendInterfaceOrTimeTime(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToBytes(ctx context.Context, recv <-chan struct{}, send chan<- Bytes, mapF func(struct{}, bool) (Bytes, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan struct{} = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrBytes(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToBool(ctx context.Context, recv <-chan struct{}, send chan<- bool, mapF func(struct{}, bool) (bool, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan struct{} = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrBool(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToByte(ctx context.Context, recv <-chan struct{}, send chan<- byte, mapF func(struct{}, bool) (byte, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan struct{} = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrByte(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToComplex128(ctx context.Context, recv <-chan struct{}, send chan<- complex128, mapF func(struct{}, bool) (complex128, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan struct{} = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrComplex128(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToComplex64(ctx context.Context, recv <-chan struct{}, send chan<- complex64, mapF func(struct{}, bool) (complex64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan struct{} = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrComplex64(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToError(ctx context.Context, recv <-chan struct{}, send chan<- error, mapF func(struct{}, bool) (error, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan struct{} = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrError(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToFloat32(ctx context.Context, recv <-chan struct{}, send chan<- float32, mapF func(struct{}, bool) (float32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan struct{} = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrFloat32(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToFloat64(ctx context.Context, recv <-chan struct{}, send chan<- float64, mapF func(struct{}, bool) (float64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan struct{} = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrFloat64(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToInt(ctx context.Context, recv <-chan struct{}, send chan<- int, mapF func(struct{}, bool) (int, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan struct{} = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrInt(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToInt16(ctx context.Context, recv <-chan struct{}, send chan<- int16, mapF func(struct{}, bool) (int16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan struct{} = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrInt16(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToInt32(ctx context.Context, recv <-chan struct{}, send chan<- int32, mapF func(struct{}, bool) (int32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan struct{} = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrInt32(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToInt64(ctx context.Context, recv <-chan struct{}, send chan<- int64, mapF func(struct{}, bool) (int64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan struct{} = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrInt64(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToInt8(ctx context.Context, recv <-chan struct{}, send chan<- int8, mapF func(struct{}, bool) (int8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan struct{} = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrInt8(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToRune(ctx context.Context, recv <-chan struct{}, send chan<- rune, mapF func(struct{}, bool) (rune, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan struct{} = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrRune(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToString(ctx context.Context, recv <-chan struct{}, send chan<- string, mapF func(struct{}, bool) (string, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan struct{} = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrString(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToUint(ctx context.Context, recv <-chan struct{}, send chan<- uint, mapF func(struct{}, bool) (uint, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan struct{} = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrUint(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToUint16(ctx context.Context, recv <-chan struct{}, send chan<- uint16, mapF func(struct{}, bool) (uint16, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan struct{} = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrUint16(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToUint32(ctx context.Context, recv <-chan struct{}, send chan<- uint32, mapF func(struct{}, bool) (uint32, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan struct{} = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrUint32(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToUint64(ctx context.Context, recv <-chan struct{}, send chan<- uint64, mapF func(struct{}, bool) (uint64, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan struct{} = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrUint64(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToUint8(ctx context.Context, recv <-chan struct{}, send chan<- uint8, mapF func(struct{}, bool) (uint8, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan struct{} = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrUint8(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToUintptr(ctx context.Context, recv <-chan struct{}, send chan<- uintptr, mapF func(struct{}, bool) (uintptr, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan struct{} = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrUintptr(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToInterface(ctx context.Context, recv <-chan struct{}, send chan<- interface{}, mapF func(struct{}, bool) (interface{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan struct{} = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrInterface(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToStruct(ctx context.Context, recv <-chan struct{}, send chan<- struct{}, mapF func(struct{}, bool) (struct{}, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan struct{} = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrStruct(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func MapStructToTimeTime(ctx context.Context, recv <-chan struct{}, send chan<- time.Time, mapF func(struct{}, bool) (time.Time, error), onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan struct{} = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseSendStructOrTimeTime(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

import (
	"context"

	"github.com/mark-ahn/chans/v1/core"
	"github.com/mark-ahn/syncs"
)

func CaseRecvBytes(ctx context.Context, ch <-chan Bytes, f func(v Bytes, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendBytes(ctx context.Context, ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectBytes(ctx context.Context, recv <-chan Bytes, send chan<- Bytes, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan Bytes = recv
		var send_ch chan<- Bytes
		var to_send Bytes

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvBool(ctx context.Context, ch <-chan bool, f func(v bool, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendBool(ctx context.Context, ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectBool(ctx context.Context, recv <-chan bool, send chan<- bool, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan bool = recv
		var send_ch chan<- bool
		var to_send bool

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvByte(ctx context.Context, ch <-chan byte, f func(v byte, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendByte(ctx context.Context, ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectByte(ctx context.Context, recv <-chan byte, send chan<- byte, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan byte = recv
		var send_ch chan<- byte
		var to_send byte

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvComplex128(ctx context.Context, ch <-chan complex128, f func(v complex128, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendComplex128(ctx context.Context, ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectComplex128(ctx context.Context, recv <-chan complex128, send chan<- complex128, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan complex128 = recv
		var send_ch chan<- complex128
		var to_send complex128

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvComplex64(ctx context.Context, ch <-chan complex64, f func(v complex64, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendComplex64(ctx context.Context, ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectComplex64(ctx context.Context, recv <-chan complex64, send chan<- complex64, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan complex64 = recv
		var send_ch chan<- complex64
		var to_send complex64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvError(ctx context.Context, ch <-chan error, f func(v error, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendError(ctx context.Context, ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectError(ctx context.Context, recv <-chan error, send chan<- error, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan error = recv
		var send_ch chan<- error
		var to_send error

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvFloat32(ctx context.Context, ch <-chan float32, f func(v float32, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendFloat32(ctx context.Context, ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectFloat32(ctx context.Context, recv <-chan float32, send chan<- float32, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan float32 = recv
		var send_ch chan<- float32
		var to_send float32

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvFloat64(ctx context.Context, ch <-chan float64, f func(v float64, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendFloat64(ctx context.Context, ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectFloat64(ctx context.Context, recv <-chan float64, send chan<- float64, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan float64 = recv
		var send_ch chan<- float64
		var to_send float64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvInt(ctx context.Context, ch <-chan int, f func(v int, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendInt(ctx context.Context, ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectInt(ctx context.Context, recv <-chan int, send chan<- int, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan int = recv
		var send_ch chan<- int
		var to_send int

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvInt16(ctx context.Context, ch <-chan int16, f func(v int16, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendInt16(ctx context.Context, ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectInt16(ctx context.Context, recv <-chan int16, send chan<- int16, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan int16 = recv
		var send_ch chan<- int16
		var to_send int16

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvInt32(ctx context.Context, ch <-chan int32, f func(v int32, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendInt32(ctx context.Context, ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectInt32(ctx context.Context, recv <-chan int32, send chan<- int32, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan int32 = recv
		var send_ch chan<- int32
		var to_send int32

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvInt64(ctx context.Context, ch <-chan int64, f func(v int64, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendInt64(ctx context.Context, ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectInt64(ctx context.Context, recv <-chan int64, send chan<- int64, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan int64 = recv
		var send_ch chan<- int64
		var to_send int64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvInt8(ctx context.Context, ch <-chan int8, f func(v int8, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendInt8(ctx context.Context, ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectInt8(ctx context.Context, recv <-chan int8, send chan<- int8, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan int8 = recv
		var send_ch chan<- int8
		var to_send int8

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvRune(ctx context.Context, ch <-chan rune, f func(v rune, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendRune(ctx context.Context, ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectRune(ctx context.Context, recv <-chan rune, send chan<- rune, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan rune = recv
		var send_ch chan<- rune
		var to_send rune

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvString(ctx context.Context, ch <-chan string, f func(v string, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendString(ctx context.Context, ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectString(ctx context.Context, recv <-chan string, send chan<- string, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan string = recv
		var send_ch chan<- string
		var to_send string

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvUint(ctx context.Context, ch <-chan uint, f func(v uint, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendUint(ctx context.Context, ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectUint(ctx context.Context, recv <-chan uint, send chan<- uint, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan uint = recv
		var send_ch chan<- uint
		var to_send uint

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvUint16(ctx context.Context, ch <-chan uint16, f func(v uint16, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendUint16(ctx context.Context, ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectUint16(ctx context.Context, recv <-chan uint16, send chan<- uint16, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan uint16 = recv
		var send_ch chan<- uint16
		var to_send uint16

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvUint32(ctx context.Context, ch <-chan uint32, f func(v uint32, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendUint32(ctx context.Context, ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectUint32(ctx context.Context, recv <-chan uint32, send chan<- uint32, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan uint32 = recv
		var send_ch chan<- uint32
		var to_send uint32

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvUint64(ctx context.Context, ch <-chan uint64, f func(v uint64, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendUint64(ctx context.Context, ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectUint64(ctx context.Context, recv <-chan uint64, send chan<- uint64, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan uint64 = recv
		var send_ch chan<- uint64
		var to_send uint64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvUint8(ctx context.Context, ch <-chan uint8, f func(v uint8, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendUint8(ctx context.Context, ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectUint8(ctx context.Context, recv <-chan uint8, send chan<- uint8, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan uint8 = recv
		var send_ch chan<- uint8
		var to_send uint8

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvUintptr(ctx context.Context, ch <-chan uintptr, f func(v uintptr, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendUintptr(ctx context.Context, ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectUintptr(ctx context.Context, recv <-chan uintptr, send chan<- uintptr, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan uintptr = recv
		var send_ch chan<- uintptr
		var to_send uintptr

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvInterface(ctx context.Context, ch <-chan interface{}, f func(v interface{}, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendInterface(ctx context.Context, ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectInterface(ctx context.Context, recv <-chan interface{}, send chan<- interface{}, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan interface{} = recv
		var send_ch chan<- interface{}
		var to_send interface{}

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

func CaseRecvStruct(ctx context.Context, ch <-chan struct{}, f func(v struct{}, ok bool) core.CaseControl, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
}

func CaseSendStruct(ctx context.Context, ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-ctx.Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
}

func ConnectStruct(ctx context.Context, recv <-chan struct{}, send chan<- struct{}, onEvent func(core.CaseResult)) {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if onEvent != nil {
			onEvent(core.CASE_CANCEL)
		}
		return
	}

	go func() {
		defer cnt.Done()

		var ok bool
		var recv_ch <-chan struct{} = recv
		var send_ch chan<- struct{}
		var to_send struct{}

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-ctx.Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

}

// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

import (
	"context"
	"fmt"
	"reflect"

	"github.com/mark-ahn/hexa"
)

func OfBoolClear(ch <-chan bool) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfBoolBroadCaster struct {
	in  []<-chan bool
	out []chan<- bool
}

func NewOfBoolBroadCaster() *OfBoolBroadCaster {
	return &OfBoolBroadCaster{
		in:  make([]<-chan bool, 0),
		out: make([]chan<- bool, 0),
	}
}

func (__ *OfBoolBroadCaster) AddSources(ins ...<-chan bool) *OfBoolBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfBoolBroadCaster) AddReceivers(outs ...chan<- bool) *OfBoolBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfBoolBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(bool)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfByteClear(ch <-chan byte) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfByteBroadCaster struct {
	in  []<-chan byte
	out []chan<- byte
}

func NewOfByteBroadCaster() *OfByteBroadCaster {
	return &OfByteBroadCaster{
		in:  make([]<-chan byte, 0),
		out: make([]chan<- byte, 0),
	}
}

func (__ *OfByteBroadCaster) AddSources(ins ...<-chan byte) *OfByteBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfByteBroadCaster) AddReceivers(outs ...chan<- byte) *OfByteBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfByteBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(byte)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfComplex128Clear(ch <-chan complex128) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfComplex128BroadCaster struct {
	in  []<-chan complex128
	out []chan<- complex128
}

func NewOfComplex128BroadCaster() *OfComplex128BroadCaster {
	return &OfComplex128BroadCaster{
		in:  make([]<-chan complex128, 0),
		out: make([]chan<- complex128, 0),
	}
}

func (__ *OfComplex128BroadCaster) AddSources(ins ...<-chan complex128) *OfComplex128BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfComplex128BroadCaster) AddReceivers(outs ...chan<- complex128) *OfComplex128BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfComplex128BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(complex128)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfComplex64Clear(ch <-chan complex64) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfComplex64BroadCaster struct {
	in  []<-chan complex64
	out []chan<- complex64
}

func NewOfComplex64BroadCaster() *OfComplex64BroadCaster {
	return &OfComplex64BroadCaster{
		in:  make([]<-chan complex64, 0),
		out: make([]chan<- complex64, 0),
	}
}

func (__ *OfComplex64BroadCaster) AddSources(ins ...<-chan complex64) *OfComplex64BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfComplex64BroadCaster) AddReceivers(outs ...chan<- complex64) *OfComplex64BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfComplex64BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(complex64)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfErrorClear(ch <-chan error) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfErrorBroadCaster struct {
	in  []<-chan error
	out []chan<- error
}

func NewOfErrorBroadCaster() *OfErrorBroadCaster {
	return &OfErrorBroadCaster{
		in:  make([]<-chan error, 0),
		out: make([]chan<- error, 0),
	}
}

func (__ *OfErrorBroadCaster) AddSources(ins ...<-chan error) *OfErrorBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfErrorBroadCaster) AddReceivers(outs ...chan<- error) *OfErrorBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfErrorBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(error)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfFloat32Clear(ch <-chan float32) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfFloat32BroadCaster struct {
	in  []<-chan float32
	out []chan<- float32
}

func NewOfFloat32BroadCaster() *OfFloat32BroadCaster {
	return &OfFloat32BroadCaster{
		in:  make([]<-chan float32, 0),
		out: make([]chan<- float32, 0),
	}
}

func (__ *OfFloat32BroadCaster) AddSources(ins ...<-chan float32) *OfFloat32BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfFloat32BroadCaster) AddReceivers(outs ...chan<- float32) *OfFloat32BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfFloat32BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(float32)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfFloat64Clear(ch <-chan float64) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfFloat64BroadCaster struct {
	in  []<-chan float64
	out []chan<- float64
}

func NewOfFloat64BroadCaster() *OfFloat64BroadCaster {
	return &OfFloat64BroadCaster{
		in:  make([]<-chan float64, 0),
		out: make([]chan<- float64, 0),
	}
}

func (__ *OfFloat64BroadCaster) AddSources(ins ...<-chan float64) *OfFloat64BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfFloat64BroadCaster) AddReceivers(outs ...chan<- float64) *OfFloat64BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfFloat64BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(float64)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfIntClear(ch <-chan int) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfIntBroadCaster struct {
	in  []<-chan int
	out []chan<- int
}

func NewOfIntBroadCaster() *OfIntBroadCaster {
	return &OfIntBroadCaster{
		in:  make([]<-chan int, 0),
		out: make([]chan<- int, 0),
	}
}

func (__ *OfIntBroadCaster) AddSources(ins ...<-chan int) *OfIntBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfIntBroadCaster) AddReceivers(outs ...chan<- int) *OfIntBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfIntBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfInt16Clear(ch <-chan int16) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInt16BroadCaster struct {
	in  []<-chan int16
	out []chan<- int16
}

func NewOfInt16BroadCaster() *OfInt16BroadCaster {
	return &OfInt16BroadCaster{
		in:  make([]<-chan int16, 0),
		out: make([]chan<- int16, 0),
	}
}

func (__ *OfInt16BroadCaster) AddSources(ins ...<-chan int16) *OfInt16BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInt16BroadCaster) AddReceivers(outs ...chan<- int16) *OfInt16BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInt16BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int16)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfInt32Clear(ch <-chan int32) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInt32BroadCaster struct {
	in  []<-chan int32
	out []chan<- int32
}

func NewOfInt32BroadCaster() *OfInt32BroadCaster {
	return &OfInt32BroadCaster{
		in:  make([]<-chan int32, 0),
		out: make([]chan<- int32, 0),
	}
}

func (__ *OfInt32BroadCaster) AddSources(ins ...<-chan int32) *OfInt32BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInt32BroadCaster) AddReceivers(outs ...chan<- int32) *OfInt32BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInt32BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int32)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfInt64Clear(ch <-chan int64) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInt64BroadCaster struct {
	in  []<-chan int64
	out []chan<- int64
}

func NewOfInt64BroadCaster() *OfInt64BroadCaster {
	return &OfInt64BroadCaster{
		in:  make([]<-chan int64, 0),
		out: make([]chan<- int64, 0),
	}
}

func (__ *OfInt64BroadCaster) AddSources(ins ...<-chan int64) *OfInt64BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInt64BroadCaster) AddReceivers(outs ...chan<- int64) *OfInt64BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInt64BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int64)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfInt8Clear(ch <-chan int8) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInt8BroadCaster struct {
	in  []<-chan int8
	out []chan<- int8
}

func NewOfInt8BroadCaster() *OfInt8BroadCaster {
	return &OfInt8BroadCaster{
		in:  make([]<-chan int8, 0),
		out: make([]chan<- int8, 0),
	}
}

func (__ *OfInt8BroadCaster) AddSources(ins ...<-chan int8) *OfInt8BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInt8BroadCaster) AddReceivers(outs ...chan<- int8) *OfInt8BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInt8BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(int8)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfRuneClear(ch <-chan rune) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfRuneBroadCaster struct {
	in  []<-chan rune
	out []chan<- rune
}

func NewOfRuneBroadCaster() *OfRuneBroadCaster {
	return &OfRuneBroadCaster{
		in:  make([]<-chan rune, 0),
		out: make([]chan<- rune, 0),
	}
}

func (__ *OfRuneBroadCaster) AddSources(ins ...<-chan rune) *OfRuneBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfRuneBroadCaster) AddReceivers(outs ...chan<- rune) *OfRuneBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfRuneBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(rune)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfStringClear(ch <-chan string) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfStringBroadCaster struct {
	in  []<-chan string
	out []chan<- string
}

func NewOfStringBroadCaster() *OfStringBroadCaster {
	return &OfStringBroadCaster{
		in:  make([]<-chan string, 0),
		out: make([]chan<- string, 0),
	}
}

func (__ *OfStringBroadCaster) AddSources(ins ...<-chan string) *OfStringBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfStringBroadCaster) AddReceivers(outs ...chan<- string) *OfStringBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfStringBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(string)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfUintClear(ch <-chan uint) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUintBroadCaster struct {
	in  []<-chan uint
	out []chan<- uint
}

func NewOfUintBroadCaster() *OfUintBroadCaster {
	return &OfUintBroadCaster{
		in:  make([]<-chan uint, 0),
		out: make([]chan<- uint, 0),
	}
}

func (__ *OfUintBroadCaster) AddSources(ins ...<-chan uint) *OfUintBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUintBroadCaster) AddReceivers(outs ...chan<- uint) *OfUintBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUintBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfUint16Clear(ch <-chan uint16) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUint16BroadCaster struct {
	in  []<-chan uint16
	out []chan<- uint16
}

func NewOfUint16BroadCaster() *OfUint16BroadCaster {
	return &OfUint16BroadCaster{
		in:  make([]<-chan uint16, 0),
		out: make([]chan<- uint16, 0),
	}
}

func (__ *OfUint16BroadCaster) AddSources(ins ...<-chan uint16) *OfUint16BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUint16BroadCaster) AddReceivers(outs ...chan<- uint16) *OfUint16BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUint16BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint16)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfUint32Clear(ch <-chan uint32) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUint32BroadCaster struct {
	in  []<-chan uint32
	out []chan<- uint32
}

func NewOfUint32BroadCaster() *OfUint32BroadCaster {
	return &OfUint32BroadCaster{
		in:  make([]<-chan uint32, 0),
		out: make([]chan<- uint32, 0),
	}
}

func (__ *OfUint32BroadCaster) AddSources(ins ...<-chan uint32) *OfUint32BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUint32BroadCaster) AddReceivers(outs ...chan<- uint32) *OfUint32BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUint32BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint32)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfUint64Clear(ch <-chan uint64) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUint64BroadCaster struct {
	in  []<-chan uint64
	out []chan<- uint64
}

func NewOfUint64BroadCaster() *OfUint64BroadCaster {
	return &OfUint64BroadCaster{
		in:  make([]<-chan uint64, 0),
		out: make([]chan<- uint64, 0),
	}
}

func (__ *OfUint64BroadCaster) AddSources(ins ...<-chan uint64) *OfUint64BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUint64BroadCaster) AddReceivers(outs ...chan<- uint64) *OfUint64BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUint64BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint64)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfUint8Clear(ch <-chan uint8) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUint8BroadCaster struct {
	in  []<-chan uint8
	out []chan<- uint8
}

func NewOfUint8BroadCaster() *OfUint8BroadCaster {
	return &OfUint8BroadCaster{
		in:  make([]<-chan uint8, 0),
		out: make([]chan<- uint8, 0),
	}
}

func (__ *OfUint8BroadCaster) AddSources(ins ...<-chan uint8) *OfUint8BroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUint8BroadCaster) AddReceivers(outs ...chan<- uint8) *OfUint8BroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUint8BroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uint8)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfUintptrClear(ch <-chan uintptr) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfUintptrBroadCaster struct {
	in  []<-chan uintptr
	out []chan<- uintptr
}

func NewOfUintptrBroadCaster() *OfUintptrBroadCaster {
	return &OfUintptrBroadCaster{
		in:  make([]<-chan uintptr, 0),
		out: make([]chan<- uintptr, 0),
	}
}

func (__ *OfUintptrBroadCaster) AddSources(ins ...<-chan uintptr) *OfUintptrBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfUintptrBroadCaster) AddReceivers(outs ...chan<- uintptr) *OfUintptrBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfUintptrBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(uintptr)
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfInterfaceClear(ch <-chan interface{}) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfInterfaceBroadCaster struct {
	in  []<-chan interface{}
	out []chan<- interface{}
}

func NewOfInterfaceBroadCaster() *OfInterfaceBroadCaster {
	return &OfInterfaceBroadCaster{
		in:  make([]<-chan interface{}, 0),
		out: make([]chan<- interface{}, 0),
	}
}

func (__ *OfInterfaceBroadCaster) AddSources(ins ...<-chan interface{}) *OfInterfaceBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfInterfaceBroadCaster) AddReceivers(outs ...chan<- interface{}) *OfInterfaceBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfInterfaceBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(interface{})
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

func OfStructClear(ch <-chan struct{}) int {
	n := len(ch)
	for i := 0; i < n; i += 1 {
		<-ch
	}
	return n
}

type OfStructBroadCaster struct {
	in  []<-chan struct{}
	out []chan<- struct{}
}

func NewOfStructBroadCaster() *OfStructBroadCaster {
	return &OfStructBroadCaster{
		in:  make([]<-chan struct{}, 0),
		out: make([]chan<- struct{}, 0),
	}
}

func (__ *OfStructBroadCaster) AddSources(ins ...<-chan struct{}) *OfStructBroadCaster {
	__.in = append(__.in, ins...)
	return __
}

func (__ *OfStructBroadCaster) AddReceivers(outs ...chan<- struct{}) *OfStructBroadCaster {
	__.out = append(__.out, outs...)
	return __
}

func (__ *OfStructBroadCaster) Serve() hexa.StoppableOne {
	ctx_stop := hexa.NewContextStop(context.Background())
	go func() {
		defer func() {
			for _, ch := range __.out {
				close(ch)
			}
			ctx_stop.InClose()
		}()

		read_cases := make([]reflect.SelectCase, len(__.in)+1)
		for i := range __.in {
			read_cases[i] = reflect.SelectCase{
				Chan: reflect.ValueOf(__.in[i]),
				Dir:  reflect.SelectRecv,
			}
		}
		read_cases[len(__.in)] = reflect.SelectCase{
			Chan: reflect.ValueOf(ctx_stop.InDoneNotify()),
			Dir:  reflect.SelectRecv,
		}
	loop:
		for {
			chosen, recv, recvOK := reflect.Select(read_cases)
			switch {
			case chosen < len(__.in):
			default:
				break loop
			}
			if !recvOK {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			d, ok := recv.Interface().(struct{})
			if !ok {
				ctx_stop.InBreak(fmt.Errorf("receive channel #%v is broken", chosen))
				continue
			}
			for i := range __.out {
				select {
				case __.out[i] <- d:
				default:
					fmt.Printf("send channel #%v is blocked - skip sending %v", i, d)
				}
			}
		}
	}()
	return ctx_stop
}

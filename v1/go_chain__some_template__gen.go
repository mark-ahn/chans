// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

func (__ *GoChain) CaseRecvBytes(ch <-chan Bytes, f func(v Bytes, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendBytes(ch chan<- Bytes, v Bytes, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectBytes(recv <-chan Bytes, send chan<- Bytes) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvBool(ch <-chan bool, f func(v bool, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendBool(ch chan<- bool, v bool, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectBool(recv <-chan bool, send chan<- bool) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvByte(ch <-chan byte, f func(v byte, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendByte(ch chan<- byte, v byte, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectByte(recv <-chan byte, send chan<- byte) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvComplex128(ch <-chan complex128, f func(v complex128, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendComplex128(ch chan<- complex128, v complex128, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectComplex128(recv <-chan complex128, send chan<- complex128) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvComplex64(ch <-chan complex64, f func(v complex64, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendComplex64(ch chan<- complex64, v complex64, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectComplex64(recv <-chan complex64, send chan<- complex64) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvError(ch <-chan error, f func(v error, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendError(ch chan<- error, v error, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectError(recv <-chan error, send chan<- error) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvFloat32(ch <-chan float32, f func(v float32, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendFloat32(ch chan<- float32, v float32, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectFloat32(recv <-chan float32, send chan<- float32) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvFloat64(ch <-chan float64, f func(v float64, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendFloat64(ch chan<- float64, v float64, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectFloat64(recv <-chan float64, send chan<- float64) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt(ch <-chan int, f func(v int, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt(ch chan<- int, v int, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt(recv <-chan int, send chan<- int) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt16(ch <-chan int16, f func(v int16, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt16(ch chan<- int16, v int16, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt16(recv <-chan int16, send chan<- int16) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt32(ch <-chan int32, f func(v int32, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt32(ch chan<- int32, v int32, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt32(recv <-chan int32, send chan<- int32) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt64(ch <-chan int64, f func(v int64, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt64(ch chan<- int64, v int64, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt64(recv <-chan int64, send chan<- int64) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt8(ch <-chan int8, f func(v int8, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt8(ch chan<- int8, v int8, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt8(recv <-chan int8, send chan<- int8) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvRune(ch <-chan rune, f func(v rune, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendRune(ch chan<- rune, v rune, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectRune(recv <-chan rune, send chan<- rune) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvString(ch <-chan string, f func(v string, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendString(ch chan<- string, v string, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectString(recv <-chan string, send chan<- string) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint(ch <-chan uint, f func(v uint, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint(ch chan<- uint, v uint, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint(recv <-chan uint, send chan<- uint) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint16(ch <-chan uint16, f func(v uint16, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint16(ch chan<- uint16, v uint16, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint16(recv <-chan uint16, send chan<- uint16) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint32(ch <-chan uint32, f func(v uint32, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint32(ch chan<- uint32, v uint32, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint32(recv <-chan uint32, send chan<- uint32) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint64(ch <-chan uint64, f func(v uint64, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint64(ch chan<- uint64, v uint64, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint64(recv <-chan uint64, send chan<- uint64) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint8(ch <-chan uint8, f func(v uint8, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint8(ch chan<- uint8, v uint8, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint8(recv <-chan uint8, send chan<- uint8) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUintptr(ch <-chan uintptr, f func(v uintptr, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUintptr(ch chan<- uintptr, v uintptr, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUintptr(recv <-chan uintptr, send chan<- uintptr) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInterface(ch <-chan interface{}, f func(v interface{}, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInterface(ch chan<- interface{}, v interface{}, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInterface(recv <-chan interface{}, send chan<- interface{}) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvStruct(ch <-chan struct{}, f func(v struct{}, ok bool) CaseControl) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				switch f(v, ok) {
				case CASE_OK:
					continue
				default:
					break loop
				}
			case <-__.ctx.Done():
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendStruct(ch chan<- struct{}, v struct{}, f func(sent CaseSend), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if f != nil {
				f(CASE_SENT)
			}
		case <-elseCh:
			if f != nil {
				f(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if f != nil {
				f(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectStruct(recv <-chan struct{}, send chan<- struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

	loop:
		for {
			select {
			case d, ok := <-recv:
				if !ok {
					break loop
				}
				send <- d
			case <-__.ctx.Done():
				break loop
			}
		}
	}()

	return __
}

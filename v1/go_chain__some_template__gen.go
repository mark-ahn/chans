// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

func (__ *GoChain) CaseRecvBytes(ch <-chan Bytes, f func(v Bytes, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendBytes(ch chan<- Bytes, v Bytes, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectBytes(recv <-chan Bytes, send chan<- Bytes, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan Bytes = recv
		var send_ch chan<- Bytes
		var to_send Bytes

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvBool(ch <-chan bool, f func(v bool, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendBool(ch chan<- bool, v bool, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectBool(recv <-chan bool, send chan<- bool, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan bool = recv
		var send_ch chan<- bool
		var to_send bool

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvByte(ch <-chan byte, f func(v byte, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendByte(ch chan<- byte, v byte, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectByte(recv <-chan byte, send chan<- byte, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan byte = recv
		var send_ch chan<- byte
		var to_send byte

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvComplex128(ch <-chan complex128, f func(v complex128, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendComplex128(ch chan<- complex128, v complex128, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectComplex128(recv <-chan complex128, send chan<- complex128, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan complex128 = recv
		var send_ch chan<- complex128
		var to_send complex128

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvComplex64(ch <-chan complex64, f func(v complex64, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendComplex64(ch chan<- complex64, v complex64, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectComplex64(recv <-chan complex64, send chan<- complex64, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan complex64 = recv
		var send_ch chan<- complex64
		var to_send complex64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvError(ch <-chan error, f func(v error, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendError(ch chan<- error, v error, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectError(recv <-chan error, send chan<- error, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan error = recv
		var send_ch chan<- error
		var to_send error

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvFloat32(ch <-chan float32, f func(v float32, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendFloat32(ch chan<- float32, v float32, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectFloat32(recv <-chan float32, send chan<- float32, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan float32 = recv
		var send_ch chan<- float32
		var to_send float32

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvFloat64(ch <-chan float64, f func(v float64, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendFloat64(ch chan<- float64, v float64, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectFloat64(recv <-chan float64, send chan<- float64, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan float64 = recv
		var send_ch chan<- float64
		var to_send float64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt(ch <-chan int, f func(v int, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt(ch chan<- int, v int, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt(recv <-chan int, send chan<- int, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan int = recv
		var send_ch chan<- int
		var to_send int

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt16(ch <-chan int16, f func(v int16, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt16(ch chan<- int16, v int16, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt16(recv <-chan int16, send chan<- int16, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan int16 = recv
		var send_ch chan<- int16
		var to_send int16

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt32(ch <-chan int32, f func(v int32, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt32(ch chan<- int32, v int32, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt32(recv <-chan int32, send chan<- int32, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan int32 = recv
		var send_ch chan<- int32
		var to_send int32

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt64(ch <-chan int64, f func(v int64, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt64(ch chan<- int64, v int64, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt64(recv <-chan int64, send chan<- int64, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan int64 = recv
		var send_ch chan<- int64
		var to_send int64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInt8(ch <-chan int8, f func(v int8, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInt8(ch chan<- int8, v int8, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInt8(recv <-chan int8, send chan<- int8, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan int8 = recv
		var send_ch chan<- int8
		var to_send int8

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvRune(ch <-chan rune, f func(v rune, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendRune(ch chan<- rune, v rune, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectRune(recv <-chan rune, send chan<- rune, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan rune = recv
		var send_ch chan<- rune
		var to_send rune

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvString(ch <-chan string, f func(v string, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendString(ch chan<- string, v string, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectString(recv <-chan string, send chan<- string, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan string = recv
		var send_ch chan<- string
		var to_send string

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint(ch <-chan uint, f func(v uint, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint(ch chan<- uint, v uint, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint(recv <-chan uint, send chan<- uint, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan uint = recv
		var send_ch chan<- uint
		var to_send uint

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint16(ch <-chan uint16, f func(v uint16, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint16(ch chan<- uint16, v uint16, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint16(recv <-chan uint16, send chan<- uint16, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan uint16 = recv
		var send_ch chan<- uint16
		var to_send uint16

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint32(ch <-chan uint32, f func(v uint32, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint32(ch chan<- uint32, v uint32, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint32(recv <-chan uint32, send chan<- uint32, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan uint32 = recv
		var send_ch chan<- uint32
		var to_send uint32

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint64(ch <-chan uint64, f func(v uint64, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint64(ch chan<- uint64, v uint64, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint64(recv <-chan uint64, send chan<- uint64, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan uint64 = recv
		var send_ch chan<- uint64
		var to_send uint64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUint8(ch <-chan uint8, f func(v uint8, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUint8(ch chan<- uint8, v uint8, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUint8(recv <-chan uint8, send chan<- uint8, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan uint8 = recv
		var send_ch chan<- uint8
		var to_send uint8

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvUintptr(ch <-chan uintptr, f func(v uintptr, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendUintptr(ch chan<- uintptr, v uintptr, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectUintptr(recv <-chan uintptr, send chan<- uintptr, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan uintptr = recv
		var send_ch chan<- uintptr
		var to_send uintptr

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvInterface(ch <-chan interface{}, f func(v interface{}, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendInterface(ch chan<- interface{}, v interface{}, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectInterface(recv <-chan interface{}, send chan<- interface{}, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan interface{} = recv
		var send_ch chan<- interface{}
		var to_send interface{}

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *GoChain) CaseRecvStruct(ch <-chan struct{}, f func(v struct{}, ok bool) CaseControl, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *GoChain) CaseSendStruct(ch chan<- struct{}, v struct{}, onEvent func(sent CaseResult), elseCh <-chan struct{}) *GoChain {
	__.threads.Add(1)
	go func() {
		defer __.threads.Done()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(CASE_ELSE)
			}
		case <-__.ctx.Done():
			if onEvent != nil {
				onEvent(CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *GoChain) ConnectStruct(recv <-chan struct{}, send chan<- struct{}, onEvent func(CaseResult)) *GoChain {
	__.threads.Add(1)
	go func() {
		__.threads.Done()

		var ok bool
		var recv_ch <-chan struct{} = recv
		var send_ch chan<- struct{}
		var to_send struct{}

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.ctx.Done():
				if onEvent != nil {
					onEvent(CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

import (
	"context"
	"fmt"

	"github.com/mark-ahn/chans/v1/core"
	"github.com/mark-ahn/syncs"
)

func OfFuncBytes(ctx context.Context, f func() (Bytes, error), n int) (<-chan Bytes, error) {

	ch := make(chan Bytes, n)
	err := OfFuncBytesWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncBytesWith(ctx context.Context, f func() (Bytes, error), ch chan<- Bytes, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncBytesSingleShot(ctx context.Context, f func() (Bytes, error), n int) (<-chan Bytes, error) {

	ch := make(chan Bytes, n)
	err := OfFuncBytesWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncBytesWithSingleShot(ctx context.Context, f func() (Bytes, error), ch chan<- Bytes, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncBool(ctx context.Context, f func() (bool, error), n int) (<-chan bool, error) {

	ch := make(chan bool, n)
	err := OfFuncBoolWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncBoolWith(ctx context.Context, f func() (bool, error), ch chan<- bool, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncBoolSingleShot(ctx context.Context, f func() (bool, error), n int) (<-chan bool, error) {

	ch := make(chan bool, n)
	err := OfFuncBoolWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncBoolWithSingleShot(ctx context.Context, f func() (bool, error), ch chan<- bool, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncByte(ctx context.Context, f func() (byte, error), n int) (<-chan byte, error) {

	ch := make(chan byte, n)
	err := OfFuncByteWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncByteWith(ctx context.Context, f func() (byte, error), ch chan<- byte, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncByteSingleShot(ctx context.Context, f func() (byte, error), n int) (<-chan byte, error) {

	ch := make(chan byte, n)
	err := OfFuncByteWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncByteWithSingleShot(ctx context.Context, f func() (byte, error), ch chan<- byte, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncComplex128(ctx context.Context, f func() (complex128, error), n int) (<-chan complex128, error) {

	ch := make(chan complex128, n)
	err := OfFuncComplex128With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncComplex128With(ctx context.Context, f func() (complex128, error), ch chan<- complex128, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncComplex128SingleShot(ctx context.Context, f func() (complex128, error), n int) (<-chan complex128, error) {

	ch := make(chan complex128, n)
	err := OfFuncComplex128WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncComplex128WithSingleShot(ctx context.Context, f func() (complex128, error), ch chan<- complex128, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncComplex64(ctx context.Context, f func() (complex64, error), n int) (<-chan complex64, error) {

	ch := make(chan complex64, n)
	err := OfFuncComplex64With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncComplex64With(ctx context.Context, f func() (complex64, error), ch chan<- complex64, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncComplex64SingleShot(ctx context.Context, f func() (complex64, error), n int) (<-chan complex64, error) {

	ch := make(chan complex64, n)
	err := OfFuncComplex64WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncComplex64WithSingleShot(ctx context.Context, f func() (complex64, error), ch chan<- complex64, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncError(ctx context.Context, f func() (error, error), n int) (<-chan error, error) {

	ch := make(chan error, n)
	err := OfFuncErrorWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncErrorWith(ctx context.Context, f func() (error, error), ch chan<- error, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncErrorSingleShot(ctx context.Context, f func() (error, error), n int) (<-chan error, error) {

	ch := make(chan error, n)
	err := OfFuncErrorWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncErrorWithSingleShot(ctx context.Context, f func() (error, error), ch chan<- error, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncFloat32(ctx context.Context, f func() (float32, error), n int) (<-chan float32, error) {

	ch := make(chan float32, n)
	err := OfFuncFloat32With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncFloat32With(ctx context.Context, f func() (float32, error), ch chan<- float32, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncFloat32SingleShot(ctx context.Context, f func() (float32, error), n int) (<-chan float32, error) {

	ch := make(chan float32, n)
	err := OfFuncFloat32WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncFloat32WithSingleShot(ctx context.Context, f func() (float32, error), ch chan<- float32, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncFloat64(ctx context.Context, f func() (float64, error), n int) (<-chan float64, error) {

	ch := make(chan float64, n)
	err := OfFuncFloat64With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncFloat64With(ctx context.Context, f func() (float64, error), ch chan<- float64, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncFloat64SingleShot(ctx context.Context, f func() (float64, error), n int) (<-chan float64, error) {

	ch := make(chan float64, n)
	err := OfFuncFloat64WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncFloat64WithSingleShot(ctx context.Context, f func() (float64, error), ch chan<- float64, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncInt(ctx context.Context, f func() (int, error), n int) (<-chan int, error) {

	ch := make(chan int, n)
	err := OfFuncIntWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncIntWith(ctx context.Context, f func() (int, error), ch chan<- int, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncIntSingleShot(ctx context.Context, f func() (int, error), n int) (<-chan int, error) {

	ch := make(chan int, n)
	err := OfFuncIntWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncIntWithSingleShot(ctx context.Context, f func() (int, error), ch chan<- int, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncInt16(ctx context.Context, f func() (int16, error), n int) (<-chan int16, error) {

	ch := make(chan int16, n)
	err := OfFuncInt16With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInt16With(ctx context.Context, f func() (int16, error), ch chan<- int16, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncInt16SingleShot(ctx context.Context, f func() (int16, error), n int) (<-chan int16, error) {

	ch := make(chan int16, n)
	err := OfFuncInt16WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInt16WithSingleShot(ctx context.Context, f func() (int16, error), ch chan<- int16, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncInt32(ctx context.Context, f func() (int32, error), n int) (<-chan int32, error) {

	ch := make(chan int32, n)
	err := OfFuncInt32With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInt32With(ctx context.Context, f func() (int32, error), ch chan<- int32, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncInt32SingleShot(ctx context.Context, f func() (int32, error), n int) (<-chan int32, error) {

	ch := make(chan int32, n)
	err := OfFuncInt32WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInt32WithSingleShot(ctx context.Context, f func() (int32, error), ch chan<- int32, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncInt64(ctx context.Context, f func() (int64, error), n int) (<-chan int64, error) {

	ch := make(chan int64, n)
	err := OfFuncInt64With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInt64With(ctx context.Context, f func() (int64, error), ch chan<- int64, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncInt64SingleShot(ctx context.Context, f func() (int64, error), n int) (<-chan int64, error) {

	ch := make(chan int64, n)
	err := OfFuncInt64WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInt64WithSingleShot(ctx context.Context, f func() (int64, error), ch chan<- int64, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncInt8(ctx context.Context, f func() (int8, error), n int) (<-chan int8, error) {

	ch := make(chan int8, n)
	err := OfFuncInt8With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInt8With(ctx context.Context, f func() (int8, error), ch chan<- int8, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncInt8SingleShot(ctx context.Context, f func() (int8, error), n int) (<-chan int8, error) {

	ch := make(chan int8, n)
	err := OfFuncInt8WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInt8WithSingleShot(ctx context.Context, f func() (int8, error), ch chan<- int8, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncRune(ctx context.Context, f func() (rune, error), n int) (<-chan rune, error) {

	ch := make(chan rune, n)
	err := OfFuncRuneWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncRuneWith(ctx context.Context, f func() (rune, error), ch chan<- rune, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncRuneSingleShot(ctx context.Context, f func() (rune, error), n int) (<-chan rune, error) {

	ch := make(chan rune, n)
	err := OfFuncRuneWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncRuneWithSingleShot(ctx context.Context, f func() (rune, error), ch chan<- rune, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncString(ctx context.Context, f func() (string, error), n int) (<-chan string, error) {

	ch := make(chan string, n)
	err := OfFuncStringWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncStringWith(ctx context.Context, f func() (string, error), ch chan<- string, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncStringSingleShot(ctx context.Context, f func() (string, error), n int) (<-chan string, error) {

	ch := make(chan string, n)
	err := OfFuncStringWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncStringWithSingleShot(ctx context.Context, f func() (string, error), ch chan<- string, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncUint(ctx context.Context, f func() (uint, error), n int) (<-chan uint, error) {

	ch := make(chan uint, n)
	err := OfFuncUintWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUintWith(ctx context.Context, f func() (uint, error), ch chan<- uint, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncUintSingleShot(ctx context.Context, f func() (uint, error), n int) (<-chan uint, error) {

	ch := make(chan uint, n)
	err := OfFuncUintWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUintWithSingleShot(ctx context.Context, f func() (uint, error), ch chan<- uint, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncUint16(ctx context.Context, f func() (uint16, error), n int) (<-chan uint16, error) {

	ch := make(chan uint16, n)
	err := OfFuncUint16With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUint16With(ctx context.Context, f func() (uint16, error), ch chan<- uint16, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncUint16SingleShot(ctx context.Context, f func() (uint16, error), n int) (<-chan uint16, error) {

	ch := make(chan uint16, n)
	err := OfFuncUint16WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUint16WithSingleShot(ctx context.Context, f func() (uint16, error), ch chan<- uint16, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncUint32(ctx context.Context, f func() (uint32, error), n int) (<-chan uint32, error) {

	ch := make(chan uint32, n)
	err := OfFuncUint32With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUint32With(ctx context.Context, f func() (uint32, error), ch chan<- uint32, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncUint32SingleShot(ctx context.Context, f func() (uint32, error), n int) (<-chan uint32, error) {

	ch := make(chan uint32, n)
	err := OfFuncUint32WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUint32WithSingleShot(ctx context.Context, f func() (uint32, error), ch chan<- uint32, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncUint64(ctx context.Context, f func() (uint64, error), n int) (<-chan uint64, error) {

	ch := make(chan uint64, n)
	err := OfFuncUint64With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUint64With(ctx context.Context, f func() (uint64, error), ch chan<- uint64, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncUint64SingleShot(ctx context.Context, f func() (uint64, error), n int) (<-chan uint64, error) {

	ch := make(chan uint64, n)
	err := OfFuncUint64WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUint64WithSingleShot(ctx context.Context, f func() (uint64, error), ch chan<- uint64, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncUint8(ctx context.Context, f func() (uint8, error), n int) (<-chan uint8, error) {

	ch := make(chan uint8, n)
	err := OfFuncUint8With(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUint8With(ctx context.Context, f func() (uint8, error), ch chan<- uint8, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncUint8SingleShot(ctx context.Context, f func() (uint8, error), n int) (<-chan uint8, error) {

	ch := make(chan uint8, n)
	err := OfFuncUint8WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUint8WithSingleShot(ctx context.Context, f func() (uint8, error), ch chan<- uint8, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncUintptr(ctx context.Context, f func() (uintptr, error), n int) (<-chan uintptr, error) {

	ch := make(chan uintptr, n)
	err := OfFuncUintptrWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUintptrWith(ctx context.Context, f func() (uintptr, error), ch chan<- uintptr, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncUintptrSingleShot(ctx context.Context, f func() (uintptr, error), n int) (<-chan uintptr, error) {

	ch := make(chan uintptr, n)
	err := OfFuncUintptrWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncUintptrWithSingleShot(ctx context.Context, f func() (uintptr, error), ch chan<- uintptr, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncInterface(ctx context.Context, f func() (interface{}, error), n int) (<-chan interface{}, error) {

	ch := make(chan interface{}, n)
	err := OfFuncInterfaceWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInterfaceWith(ctx context.Context, f func() (interface{}, error), ch chan<- interface{}, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncInterfaceSingleShot(ctx context.Context, f func() (interface{}, error), n int) (<-chan interface{}, error) {

	ch := make(chan interface{}, n)
	err := OfFuncInterfaceWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncInterfaceWithSingleShot(ctx context.Context, f func() (interface{}, error), ch chan<- interface{}, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

func OfFuncStruct(ctx context.Context, f func() (struct{}, error), n int) (<-chan struct{}, error) {

	ch := make(chan struct{}, n)
	err := OfFuncStructWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncStructWith(ctx context.Context, f func() (struct{}, error), ch chan<- struct{}, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return nil
}

func OfFuncStructSingleShot(ctx context.Context, f func() (struct{}, error), n int) (<-chan struct{}, error) {

	ch := make(chan struct{}, n)
	err := OfFuncStructWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch, err
}

func OfFuncStructWithSingleShot(ctx context.Context, f func() (struct{}, error), ch chan<- struct{}, release func()) error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ok := cnt.AddOrNot(1)
	if !ok {
		if release != nil {
			release()
		}
		return fmt.Errorf("cannot start thread with context which has done")
	}

	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return nil
}

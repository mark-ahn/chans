// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

import (
	"context"

	"github.com/mark-ahn/chans/v1/core"
	"github.com/mark-ahn/syncs"
)

func OfFuncBytes(ctx context.Context, f func() (Bytes, error), n int) <-chan Bytes {

	ch := make(chan Bytes, n)
	OfFuncBytesWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncBytesWith(ctx context.Context, f func() (Bytes, error), ch chan<- Bytes, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncBytesSingleShot(ctx context.Context, f func() (Bytes, error), n int) <-chan Bytes {

	ch := make(chan Bytes, n)
	OfFuncBytesWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncBytesWithSingleShot(ctx context.Context, f func() (Bytes, error), ch chan<- Bytes, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncBool(ctx context.Context, f func() (bool, error), n int) <-chan bool {

	ch := make(chan bool, n)
	OfFuncBoolWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncBoolWith(ctx context.Context, f func() (bool, error), ch chan<- bool, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncBoolSingleShot(ctx context.Context, f func() (bool, error), n int) <-chan bool {

	ch := make(chan bool, n)
	OfFuncBoolWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncBoolWithSingleShot(ctx context.Context, f func() (bool, error), ch chan<- bool, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncByte(ctx context.Context, f func() (byte, error), n int) <-chan byte {

	ch := make(chan byte, n)
	OfFuncByteWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncByteWith(ctx context.Context, f func() (byte, error), ch chan<- byte, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncByteSingleShot(ctx context.Context, f func() (byte, error), n int) <-chan byte {

	ch := make(chan byte, n)
	OfFuncByteWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncByteWithSingleShot(ctx context.Context, f func() (byte, error), ch chan<- byte, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncComplex128(ctx context.Context, f func() (complex128, error), n int) <-chan complex128 {

	ch := make(chan complex128, n)
	OfFuncComplex128With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncComplex128With(ctx context.Context, f func() (complex128, error), ch chan<- complex128, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncComplex128SingleShot(ctx context.Context, f func() (complex128, error), n int) <-chan complex128 {

	ch := make(chan complex128, n)
	OfFuncComplex128WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncComplex128WithSingleShot(ctx context.Context, f func() (complex128, error), ch chan<- complex128, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncComplex64(ctx context.Context, f func() (complex64, error), n int) <-chan complex64 {

	ch := make(chan complex64, n)
	OfFuncComplex64With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncComplex64With(ctx context.Context, f func() (complex64, error), ch chan<- complex64, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncComplex64SingleShot(ctx context.Context, f func() (complex64, error), n int) <-chan complex64 {

	ch := make(chan complex64, n)
	OfFuncComplex64WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncComplex64WithSingleShot(ctx context.Context, f func() (complex64, error), ch chan<- complex64, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncError(ctx context.Context, f func() (error, error), n int) <-chan error {

	ch := make(chan error, n)
	OfFuncErrorWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncErrorWith(ctx context.Context, f func() (error, error), ch chan<- error, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncErrorSingleShot(ctx context.Context, f func() (error, error), n int) <-chan error {

	ch := make(chan error, n)
	OfFuncErrorWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncErrorWithSingleShot(ctx context.Context, f func() (error, error), ch chan<- error, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncFloat32(ctx context.Context, f func() (float32, error), n int) <-chan float32 {

	ch := make(chan float32, n)
	OfFuncFloat32With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncFloat32With(ctx context.Context, f func() (float32, error), ch chan<- float32, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncFloat32SingleShot(ctx context.Context, f func() (float32, error), n int) <-chan float32 {

	ch := make(chan float32, n)
	OfFuncFloat32WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncFloat32WithSingleShot(ctx context.Context, f func() (float32, error), ch chan<- float32, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncFloat64(ctx context.Context, f func() (float64, error), n int) <-chan float64 {

	ch := make(chan float64, n)
	OfFuncFloat64With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncFloat64With(ctx context.Context, f func() (float64, error), ch chan<- float64, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncFloat64SingleShot(ctx context.Context, f func() (float64, error), n int) <-chan float64 {

	ch := make(chan float64, n)
	OfFuncFloat64WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncFloat64WithSingleShot(ctx context.Context, f func() (float64, error), ch chan<- float64, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncInt(ctx context.Context, f func() (int, error), n int) <-chan int {

	ch := make(chan int, n)
	OfFuncIntWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncIntWith(ctx context.Context, f func() (int, error), ch chan<- int, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncIntSingleShot(ctx context.Context, f func() (int, error), n int) <-chan int {

	ch := make(chan int, n)
	OfFuncIntWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncIntWithSingleShot(ctx context.Context, f func() (int, error), ch chan<- int, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncInt16(ctx context.Context, f func() (int16, error), n int) <-chan int16 {

	ch := make(chan int16, n)
	OfFuncInt16With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInt16With(ctx context.Context, f func() (int16, error), ch chan<- int16, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncInt16SingleShot(ctx context.Context, f func() (int16, error), n int) <-chan int16 {

	ch := make(chan int16, n)
	OfFuncInt16WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInt16WithSingleShot(ctx context.Context, f func() (int16, error), ch chan<- int16, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncInt32(ctx context.Context, f func() (int32, error), n int) <-chan int32 {

	ch := make(chan int32, n)
	OfFuncInt32With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInt32With(ctx context.Context, f func() (int32, error), ch chan<- int32, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncInt32SingleShot(ctx context.Context, f func() (int32, error), n int) <-chan int32 {

	ch := make(chan int32, n)
	OfFuncInt32WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInt32WithSingleShot(ctx context.Context, f func() (int32, error), ch chan<- int32, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncInt64(ctx context.Context, f func() (int64, error), n int) <-chan int64 {

	ch := make(chan int64, n)
	OfFuncInt64With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInt64With(ctx context.Context, f func() (int64, error), ch chan<- int64, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncInt64SingleShot(ctx context.Context, f func() (int64, error), n int) <-chan int64 {

	ch := make(chan int64, n)
	OfFuncInt64WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInt64WithSingleShot(ctx context.Context, f func() (int64, error), ch chan<- int64, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncInt8(ctx context.Context, f func() (int8, error), n int) <-chan int8 {

	ch := make(chan int8, n)
	OfFuncInt8With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInt8With(ctx context.Context, f func() (int8, error), ch chan<- int8, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncInt8SingleShot(ctx context.Context, f func() (int8, error), n int) <-chan int8 {

	ch := make(chan int8, n)
	OfFuncInt8WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInt8WithSingleShot(ctx context.Context, f func() (int8, error), ch chan<- int8, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncRune(ctx context.Context, f func() (rune, error), n int) <-chan rune {

	ch := make(chan rune, n)
	OfFuncRuneWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncRuneWith(ctx context.Context, f func() (rune, error), ch chan<- rune, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncRuneSingleShot(ctx context.Context, f func() (rune, error), n int) <-chan rune {

	ch := make(chan rune, n)
	OfFuncRuneWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncRuneWithSingleShot(ctx context.Context, f func() (rune, error), ch chan<- rune, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncString(ctx context.Context, f func() (string, error), n int) <-chan string {

	ch := make(chan string, n)
	OfFuncStringWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncStringWith(ctx context.Context, f func() (string, error), ch chan<- string, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncStringSingleShot(ctx context.Context, f func() (string, error), n int) <-chan string {

	ch := make(chan string, n)
	OfFuncStringWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncStringWithSingleShot(ctx context.Context, f func() (string, error), ch chan<- string, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncUint(ctx context.Context, f func() (uint, error), n int) <-chan uint {

	ch := make(chan uint, n)
	OfFuncUintWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUintWith(ctx context.Context, f func() (uint, error), ch chan<- uint, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncUintSingleShot(ctx context.Context, f func() (uint, error), n int) <-chan uint {

	ch := make(chan uint, n)
	OfFuncUintWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUintWithSingleShot(ctx context.Context, f func() (uint, error), ch chan<- uint, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncUint16(ctx context.Context, f func() (uint16, error), n int) <-chan uint16 {

	ch := make(chan uint16, n)
	OfFuncUint16With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUint16With(ctx context.Context, f func() (uint16, error), ch chan<- uint16, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncUint16SingleShot(ctx context.Context, f func() (uint16, error), n int) <-chan uint16 {

	ch := make(chan uint16, n)
	OfFuncUint16WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUint16WithSingleShot(ctx context.Context, f func() (uint16, error), ch chan<- uint16, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncUint32(ctx context.Context, f func() (uint32, error), n int) <-chan uint32 {

	ch := make(chan uint32, n)
	OfFuncUint32With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUint32With(ctx context.Context, f func() (uint32, error), ch chan<- uint32, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncUint32SingleShot(ctx context.Context, f func() (uint32, error), n int) <-chan uint32 {

	ch := make(chan uint32, n)
	OfFuncUint32WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUint32WithSingleShot(ctx context.Context, f func() (uint32, error), ch chan<- uint32, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncUint64(ctx context.Context, f func() (uint64, error), n int) <-chan uint64 {

	ch := make(chan uint64, n)
	OfFuncUint64With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUint64With(ctx context.Context, f func() (uint64, error), ch chan<- uint64, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncUint64SingleShot(ctx context.Context, f func() (uint64, error), n int) <-chan uint64 {

	ch := make(chan uint64, n)
	OfFuncUint64WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUint64WithSingleShot(ctx context.Context, f func() (uint64, error), ch chan<- uint64, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncUint8(ctx context.Context, f func() (uint8, error), n int) <-chan uint8 {

	ch := make(chan uint8, n)
	OfFuncUint8With(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUint8With(ctx context.Context, f func() (uint8, error), ch chan<- uint8, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncUint8SingleShot(ctx context.Context, f func() (uint8, error), n int) <-chan uint8 {

	ch := make(chan uint8, n)
	OfFuncUint8WithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUint8WithSingleShot(ctx context.Context, f func() (uint8, error), ch chan<- uint8, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncUintptr(ctx context.Context, f func() (uintptr, error), n int) <-chan uintptr {

	ch := make(chan uintptr, n)
	OfFuncUintptrWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUintptrWith(ctx context.Context, f func() (uintptr, error), ch chan<- uintptr, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncUintptrSingleShot(ctx context.Context, f func() (uintptr, error), n int) <-chan uintptr {

	ch := make(chan uintptr, n)
	OfFuncUintptrWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncUintptrWithSingleShot(ctx context.Context, f func() (uintptr, error), ch chan<- uintptr, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncInterface(ctx context.Context, f func() (interface{}, error), n int) <-chan interface{} {

	ch := make(chan interface{}, n)
	OfFuncInterfaceWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInterfaceWith(ctx context.Context, f func() (interface{}, error), ch chan<- interface{}, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncInterfaceSingleShot(ctx context.Context, f func() (interface{}, error), n int) <-chan interface{} {

	ch := make(chan interface{}, n)
	OfFuncInterfaceWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncInterfaceWithSingleShot(ctx context.Context, f func() (interface{}, error), ch chan<- interface{}, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

func OfFuncStruct(ctx context.Context, f func() (struct{}, error), n int) <-chan struct{} {

	ch := make(chan struct{}, n)
	OfFuncStructWith(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncStructWith(ctx context.Context, f func() (struct{}, error), ch chan<- struct{}, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

	loop:
		for {
			t, err := f()
			switch err {
			case core.ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
}

func OfFuncStructSingleShot(ctx context.Context, f func() (struct{}, error), n int) <-chan struct{} {

	ch := make(chan struct{}, n)
	OfFuncStructWithSingleShot(ctx, f, ch, func() {
		close(ch)
	})
	return ch
}

func OfFuncStructWithSingleShot(ctx context.Context, f func() (struct{}, error), ch chan<- struct{}, release func()) {
	cnt := syncs.ThreadCounterFrom(ctx)

	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer func() {
			if release != nil {
				release()
			}
		}()

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
}

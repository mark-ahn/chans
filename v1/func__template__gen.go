// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package chans

import (
	"context"

	"github.com/mark-ahn/syncs"
)

func OfFuncBytes(ctx context.Context, f func() (Bytes, error), n int) <-chan Bytes {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan Bytes, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncBytesSingleShot(ctx context.Context, f func() (Bytes, error), n int) <-chan Bytes {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan Bytes, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncBool(ctx context.Context, f func() (bool, error), n int) <-chan bool {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan bool, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncBoolSingleShot(ctx context.Context, f func() (bool, error), n int) <-chan bool {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan bool, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncByte(ctx context.Context, f func() (byte, error), n int) <-chan byte {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan byte, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncByteSingleShot(ctx context.Context, f func() (byte, error), n int) <-chan byte {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan byte, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncComplex128(ctx context.Context, f func() (complex128, error), n int) <-chan complex128 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan complex128, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncComplex128SingleShot(ctx context.Context, f func() (complex128, error), n int) <-chan complex128 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan complex128, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncComplex64(ctx context.Context, f func() (complex64, error), n int) <-chan complex64 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan complex64, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncComplex64SingleShot(ctx context.Context, f func() (complex64, error), n int) <-chan complex64 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan complex64, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncError(ctx context.Context, f func() (error, error), n int) <-chan error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan error, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncErrorSingleShot(ctx context.Context, f func() (error, error), n int) <-chan error {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan error, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncFloat32(ctx context.Context, f func() (float32, error), n int) <-chan float32 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan float32, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncFloat32SingleShot(ctx context.Context, f func() (float32, error), n int) <-chan float32 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan float32, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncFloat64(ctx context.Context, f func() (float64, error), n int) <-chan float64 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan float64, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncFloat64SingleShot(ctx context.Context, f func() (float64, error), n int) <-chan float64 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan float64, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncInt(ctx context.Context, f func() (int, error), n int) <-chan int {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncIntSingleShot(ctx context.Context, f func() (int, error), n int) <-chan int {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncInt16(ctx context.Context, f func() (int16, error), n int) <-chan int16 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int16, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncInt16SingleShot(ctx context.Context, f func() (int16, error), n int) <-chan int16 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int16, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncInt32(ctx context.Context, f func() (int32, error), n int) <-chan int32 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int32, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncInt32SingleShot(ctx context.Context, f func() (int32, error), n int) <-chan int32 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int32, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncInt64(ctx context.Context, f func() (int64, error), n int) <-chan int64 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int64, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncInt64SingleShot(ctx context.Context, f func() (int64, error), n int) <-chan int64 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int64, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncInt8(ctx context.Context, f func() (int8, error), n int) <-chan int8 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int8, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncInt8SingleShot(ctx context.Context, f func() (int8, error), n int) <-chan int8 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan int8, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncRune(ctx context.Context, f func() (rune, error), n int) <-chan rune {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan rune, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncRuneSingleShot(ctx context.Context, f func() (rune, error), n int) <-chan rune {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan rune, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncString(ctx context.Context, f func() (string, error), n int) <-chan string {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan string, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncStringSingleShot(ctx context.Context, f func() (string, error), n int) <-chan string {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan string, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncUint(ctx context.Context, f func() (uint, error), n int) <-chan uint {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncUintSingleShot(ctx context.Context, f func() (uint, error), n int) <-chan uint {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncUint16(ctx context.Context, f func() (uint16, error), n int) <-chan uint16 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint16, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncUint16SingleShot(ctx context.Context, f func() (uint16, error), n int) <-chan uint16 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint16, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncUint32(ctx context.Context, f func() (uint32, error), n int) <-chan uint32 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint32, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncUint32SingleShot(ctx context.Context, f func() (uint32, error), n int) <-chan uint32 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint32, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncUint64(ctx context.Context, f func() (uint64, error), n int) <-chan uint64 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint64, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncUint64SingleShot(ctx context.Context, f func() (uint64, error), n int) <-chan uint64 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint64, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncUint8(ctx context.Context, f func() (uint8, error), n int) <-chan uint8 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint8, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncUint8SingleShot(ctx context.Context, f func() (uint8, error), n int) <-chan uint8 {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uint8, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncUintptr(ctx context.Context, f func() (uintptr, error), n int) <-chan uintptr {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uintptr, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncUintptrSingleShot(ctx context.Context, f func() (uintptr, error), n int) <-chan uintptr {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan uintptr, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncInterface(ctx context.Context, f func() (interface{}, error), n int) <-chan interface{} {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan interface{}, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncInterfaceSingleShot(ctx context.Context, f func() (interface{}, error), n int) <-chan interface{} {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan interface{}, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

func OfFuncStruct(ctx context.Context, f func() (struct{}, error), n int) <-chan struct{} {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan struct{}, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

	loop:
		for {
			t, err := f()
			switch err {
			case ErrStopIter:
				break loop
			case nil:
			default:
				continue
			}

			select {
			case <-ctx.Done():
				break loop
			case ch <- t:
			}

		}
	}()
	return ch
}

func OfFuncStructSingleShot(ctx context.Context, f func() (struct{}, error), n int) <-chan struct{} {
	cnt := syncs.ThreadCounterFrom(ctx)

	ch := make(chan struct{}, n)
	cnt.Add(1)
	go func() {
		defer cnt.Done()
		defer close(ch)

		t, err := f()
		if err != nil {
			return
		}

		select {
		case <-ctx.Done():
			return
		case ch <- t:
		}

	}()
	return ch
}

// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package generated

import (
	"time"

	"github.com/mark-ahn/chans/v1/core"
)

func (__ *Chain) MapBytesToBytes(recv <-chan Bytes, send chan<- Bytes, mapF func(Bytes, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan Bytes = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrBytes(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToBool(recv <-chan Bytes, send chan<- bool, mapF func(Bytes, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan Bytes = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrBool(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToByte(recv <-chan Bytes, send chan<- byte, mapF func(Bytes, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan Bytes = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrByte(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToComplex128(recv <-chan Bytes, send chan<- complex128, mapF func(Bytes, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan Bytes = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrComplex128(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToComplex64(recv <-chan Bytes, send chan<- complex64, mapF func(Bytes, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan Bytes = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrComplex64(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToError(recv <-chan Bytes, send chan<- error, mapF func(Bytes, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan Bytes = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrError(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToFloat32(recv <-chan Bytes, send chan<- float32, mapF func(Bytes, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan Bytes = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrFloat32(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToFloat64(recv <-chan Bytes, send chan<- float64, mapF func(Bytes, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan Bytes = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrFloat64(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToInt(recv <-chan Bytes, send chan<- int, mapF func(Bytes, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan Bytes = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrInt(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToInt16(recv <-chan Bytes, send chan<- int16, mapF func(Bytes, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan Bytes = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrInt16(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToInt32(recv <-chan Bytes, send chan<- int32, mapF func(Bytes, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan Bytes = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrInt32(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToInt64(recv <-chan Bytes, send chan<- int64, mapF func(Bytes, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan Bytes = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrInt64(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToInt8(recv <-chan Bytes, send chan<- int8, mapF func(Bytes, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan Bytes = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrInt8(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToRune(recv <-chan Bytes, send chan<- rune, mapF func(Bytes, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan Bytes = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrRune(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToString(recv <-chan Bytes, send chan<- string, mapF func(Bytes, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan Bytes = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrString(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToUint(recv <-chan Bytes, send chan<- uint, mapF func(Bytes, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan Bytes = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrUint(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToUint16(recv <-chan Bytes, send chan<- uint16, mapF func(Bytes, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan Bytes = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrUint16(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToUint32(recv <-chan Bytes, send chan<- uint32, mapF func(Bytes, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan Bytes = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrUint32(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToUint64(recv <-chan Bytes, send chan<- uint64, mapF func(Bytes, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan Bytes = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrUint64(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToUint8(recv <-chan Bytes, send chan<- uint8, mapF func(Bytes, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan Bytes = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrUint8(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToUintptr(recv <-chan Bytes, send chan<- uintptr, mapF func(Bytes, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan Bytes = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrUintptr(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToInterface(recv <-chan Bytes, send chan<- interface{}, mapF func(Bytes, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan Bytes = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrInterface(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToStruct(recv <-chan Bytes, send chan<- struct{}, mapF func(Bytes, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan Bytes = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrStruct(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBytesToTimeTime(recv <-chan Bytes, send chan<- time.Time, mapF func(Bytes, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan Bytes = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBytesOrTimeTime(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToBytes(recv <-chan bool, send chan<- Bytes, mapF func(bool, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan bool = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrBytes(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToBool(recv <-chan bool, send chan<- bool, mapF func(bool, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan bool = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrBool(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToByte(recv <-chan bool, send chan<- byte, mapF func(bool, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan bool = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrByte(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToComplex128(recv <-chan bool, send chan<- complex128, mapF func(bool, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan bool = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrComplex128(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToComplex64(recv <-chan bool, send chan<- complex64, mapF func(bool, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan bool = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrComplex64(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToError(recv <-chan bool, send chan<- error, mapF func(bool, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan bool = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrError(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToFloat32(recv <-chan bool, send chan<- float32, mapF func(bool, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan bool = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrFloat32(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToFloat64(recv <-chan bool, send chan<- float64, mapF func(bool, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan bool = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrFloat64(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToInt(recv <-chan bool, send chan<- int, mapF func(bool, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan bool = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrInt(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToInt16(recv <-chan bool, send chan<- int16, mapF func(bool, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan bool = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrInt16(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToInt32(recv <-chan bool, send chan<- int32, mapF func(bool, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan bool = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrInt32(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToInt64(recv <-chan bool, send chan<- int64, mapF func(bool, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan bool = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrInt64(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToInt8(recv <-chan bool, send chan<- int8, mapF func(bool, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan bool = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrInt8(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToRune(recv <-chan bool, send chan<- rune, mapF func(bool, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan bool = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrRune(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToString(recv <-chan bool, send chan<- string, mapF func(bool, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan bool = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrString(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToUint(recv <-chan bool, send chan<- uint, mapF func(bool, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan bool = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrUint(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToUint16(recv <-chan bool, send chan<- uint16, mapF func(bool, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan bool = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrUint16(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToUint32(recv <-chan bool, send chan<- uint32, mapF func(bool, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan bool = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrUint32(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToUint64(recv <-chan bool, send chan<- uint64, mapF func(bool, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan bool = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrUint64(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToUint8(recv <-chan bool, send chan<- uint8, mapF func(bool, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan bool = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrUint8(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToUintptr(recv <-chan bool, send chan<- uintptr, mapF func(bool, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan bool = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrUintptr(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToInterface(recv <-chan bool, send chan<- interface{}, mapF func(bool, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan bool = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrInterface(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToStruct(recv <-chan bool, send chan<- struct{}, mapF func(bool, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan bool = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrStruct(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapBoolToTimeTime(recv <-chan bool, send chan<- time.Time, mapF func(bool, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan bool = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendBoolOrTimeTime(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToBytes(recv <-chan byte, send chan<- Bytes, mapF func(byte, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan byte = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrBytes(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToBool(recv <-chan byte, send chan<- bool, mapF func(byte, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan byte = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrBool(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToByte(recv <-chan byte, send chan<- byte, mapF func(byte, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan byte = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrByte(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToComplex128(recv <-chan byte, send chan<- complex128, mapF func(byte, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan byte = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrComplex128(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToComplex64(recv <-chan byte, send chan<- complex64, mapF func(byte, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan byte = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrComplex64(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToError(recv <-chan byte, send chan<- error, mapF func(byte, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan byte = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrError(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToFloat32(recv <-chan byte, send chan<- float32, mapF func(byte, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan byte = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrFloat32(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToFloat64(recv <-chan byte, send chan<- float64, mapF func(byte, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan byte = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrFloat64(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToInt(recv <-chan byte, send chan<- int, mapF func(byte, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan byte = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrInt(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToInt16(recv <-chan byte, send chan<- int16, mapF func(byte, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan byte = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrInt16(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToInt32(recv <-chan byte, send chan<- int32, mapF func(byte, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan byte = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrInt32(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToInt64(recv <-chan byte, send chan<- int64, mapF func(byte, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan byte = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrInt64(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToInt8(recv <-chan byte, send chan<- int8, mapF func(byte, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan byte = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrInt8(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToRune(recv <-chan byte, send chan<- rune, mapF func(byte, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan byte = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrRune(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToString(recv <-chan byte, send chan<- string, mapF func(byte, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan byte = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrString(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToUint(recv <-chan byte, send chan<- uint, mapF func(byte, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan byte = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrUint(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToUint16(recv <-chan byte, send chan<- uint16, mapF func(byte, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan byte = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrUint16(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToUint32(recv <-chan byte, send chan<- uint32, mapF func(byte, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan byte = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrUint32(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToUint64(recv <-chan byte, send chan<- uint64, mapF func(byte, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan byte = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrUint64(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToUint8(recv <-chan byte, send chan<- uint8, mapF func(byte, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan byte = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrUint8(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToUintptr(recv <-chan byte, send chan<- uintptr, mapF func(byte, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan byte = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrUintptr(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToInterface(recv <-chan byte, send chan<- interface{}, mapF func(byte, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan byte = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrInterface(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToStruct(recv <-chan byte, send chan<- struct{}, mapF func(byte, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan byte = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrStruct(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapByteToTimeTime(recv <-chan byte, send chan<- time.Time, mapF func(byte, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan byte = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendByteOrTimeTime(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToBytes(recv <-chan complex128, send chan<- Bytes, mapF func(complex128, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan complex128 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrBytes(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToBool(recv <-chan complex128, send chan<- bool, mapF func(complex128, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan complex128 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrBool(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToByte(recv <-chan complex128, send chan<- byte, mapF func(complex128, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan complex128 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrByte(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToComplex128(recv <-chan complex128, send chan<- complex128, mapF func(complex128, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan complex128 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrComplex128(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToComplex64(recv <-chan complex128, send chan<- complex64, mapF func(complex128, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan complex128 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrComplex64(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToError(recv <-chan complex128, send chan<- error, mapF func(complex128, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan complex128 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrError(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToFloat32(recv <-chan complex128, send chan<- float32, mapF func(complex128, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan complex128 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrFloat32(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToFloat64(recv <-chan complex128, send chan<- float64, mapF func(complex128, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan complex128 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrFloat64(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToInt(recv <-chan complex128, send chan<- int, mapF func(complex128, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan complex128 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrInt(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToInt16(recv <-chan complex128, send chan<- int16, mapF func(complex128, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan complex128 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrInt16(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToInt32(recv <-chan complex128, send chan<- int32, mapF func(complex128, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan complex128 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrInt32(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToInt64(recv <-chan complex128, send chan<- int64, mapF func(complex128, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan complex128 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrInt64(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToInt8(recv <-chan complex128, send chan<- int8, mapF func(complex128, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan complex128 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrInt8(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToRune(recv <-chan complex128, send chan<- rune, mapF func(complex128, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan complex128 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrRune(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToString(recv <-chan complex128, send chan<- string, mapF func(complex128, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan complex128 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrString(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToUint(recv <-chan complex128, send chan<- uint, mapF func(complex128, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan complex128 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrUint(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToUint16(recv <-chan complex128, send chan<- uint16, mapF func(complex128, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan complex128 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrUint16(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToUint32(recv <-chan complex128, send chan<- uint32, mapF func(complex128, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan complex128 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrUint32(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToUint64(recv <-chan complex128, send chan<- uint64, mapF func(complex128, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan complex128 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrUint64(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToUint8(recv <-chan complex128, send chan<- uint8, mapF func(complex128, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan complex128 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrUint8(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToUintptr(recv <-chan complex128, send chan<- uintptr, mapF func(complex128, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan complex128 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrUintptr(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToInterface(recv <-chan complex128, send chan<- interface{}, mapF func(complex128, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan complex128 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrInterface(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToStruct(recv <-chan complex128, send chan<- struct{}, mapF func(complex128, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan complex128 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrStruct(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex128ToTimeTime(recv <-chan complex128, send chan<- time.Time, mapF func(complex128, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan complex128 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex128OrTimeTime(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToBytes(recv <-chan complex64, send chan<- Bytes, mapF func(complex64, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan complex64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrBytes(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToBool(recv <-chan complex64, send chan<- bool, mapF func(complex64, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan complex64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrBool(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToByte(recv <-chan complex64, send chan<- byte, mapF func(complex64, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan complex64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrByte(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToComplex128(recv <-chan complex64, send chan<- complex128, mapF func(complex64, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan complex64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrComplex128(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToComplex64(recv <-chan complex64, send chan<- complex64, mapF func(complex64, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan complex64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrComplex64(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToError(recv <-chan complex64, send chan<- error, mapF func(complex64, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan complex64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrError(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToFloat32(recv <-chan complex64, send chan<- float32, mapF func(complex64, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan complex64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrFloat32(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToFloat64(recv <-chan complex64, send chan<- float64, mapF func(complex64, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan complex64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrFloat64(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToInt(recv <-chan complex64, send chan<- int, mapF func(complex64, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan complex64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrInt(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToInt16(recv <-chan complex64, send chan<- int16, mapF func(complex64, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan complex64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrInt16(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToInt32(recv <-chan complex64, send chan<- int32, mapF func(complex64, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan complex64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrInt32(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToInt64(recv <-chan complex64, send chan<- int64, mapF func(complex64, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan complex64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrInt64(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToInt8(recv <-chan complex64, send chan<- int8, mapF func(complex64, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan complex64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrInt8(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToRune(recv <-chan complex64, send chan<- rune, mapF func(complex64, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan complex64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrRune(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToString(recv <-chan complex64, send chan<- string, mapF func(complex64, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan complex64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrString(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToUint(recv <-chan complex64, send chan<- uint, mapF func(complex64, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan complex64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrUint(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToUint16(recv <-chan complex64, send chan<- uint16, mapF func(complex64, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan complex64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrUint16(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToUint32(recv <-chan complex64, send chan<- uint32, mapF func(complex64, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan complex64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrUint32(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToUint64(recv <-chan complex64, send chan<- uint64, mapF func(complex64, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan complex64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrUint64(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToUint8(recv <-chan complex64, send chan<- uint8, mapF func(complex64, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan complex64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrUint8(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToUintptr(recv <-chan complex64, send chan<- uintptr, mapF func(complex64, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan complex64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrUintptr(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToInterface(recv <-chan complex64, send chan<- interface{}, mapF func(complex64, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan complex64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrInterface(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToStruct(recv <-chan complex64, send chan<- struct{}, mapF func(complex64, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan complex64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrStruct(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapComplex64ToTimeTime(recv <-chan complex64, send chan<- time.Time, mapF func(complex64, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan complex64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendComplex64OrTimeTime(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToBytes(recv <-chan error, send chan<- Bytes, mapF func(error, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan error = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrBytes(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToBool(recv <-chan error, send chan<- bool, mapF func(error, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan error = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrBool(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToByte(recv <-chan error, send chan<- byte, mapF func(error, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan error = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrByte(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToComplex128(recv <-chan error, send chan<- complex128, mapF func(error, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan error = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrComplex128(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToComplex64(recv <-chan error, send chan<- complex64, mapF func(error, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan error = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrComplex64(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToError(recv <-chan error, send chan<- error, mapF func(error, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan error = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrError(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToFloat32(recv <-chan error, send chan<- float32, mapF func(error, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan error = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrFloat32(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToFloat64(recv <-chan error, send chan<- float64, mapF func(error, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan error = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrFloat64(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToInt(recv <-chan error, send chan<- int, mapF func(error, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan error = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrInt(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToInt16(recv <-chan error, send chan<- int16, mapF func(error, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan error = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrInt16(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToInt32(recv <-chan error, send chan<- int32, mapF func(error, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan error = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrInt32(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToInt64(recv <-chan error, send chan<- int64, mapF func(error, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan error = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrInt64(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToInt8(recv <-chan error, send chan<- int8, mapF func(error, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan error = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrInt8(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToRune(recv <-chan error, send chan<- rune, mapF func(error, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan error = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrRune(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToString(recv <-chan error, send chan<- string, mapF func(error, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan error = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrString(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToUint(recv <-chan error, send chan<- uint, mapF func(error, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan error = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrUint(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToUint16(recv <-chan error, send chan<- uint16, mapF func(error, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan error = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrUint16(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToUint32(recv <-chan error, send chan<- uint32, mapF func(error, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan error = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrUint32(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToUint64(recv <-chan error, send chan<- uint64, mapF func(error, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan error = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrUint64(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToUint8(recv <-chan error, send chan<- uint8, mapF func(error, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan error = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrUint8(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToUintptr(recv <-chan error, send chan<- uintptr, mapF func(error, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan error = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrUintptr(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToInterface(recv <-chan error, send chan<- interface{}, mapF func(error, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan error = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrInterface(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToStruct(recv <-chan error, send chan<- struct{}, mapF func(error, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan error = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrStruct(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapErrorToTimeTime(recv <-chan error, send chan<- time.Time, mapF func(error, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan error = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendErrorOrTimeTime(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToBytes(recv <-chan float32, send chan<- Bytes, mapF func(float32, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan float32 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrBytes(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToBool(recv <-chan float32, send chan<- bool, mapF func(float32, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan float32 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrBool(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToByte(recv <-chan float32, send chan<- byte, mapF func(float32, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan float32 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrByte(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToComplex128(recv <-chan float32, send chan<- complex128, mapF func(float32, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan float32 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrComplex128(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToComplex64(recv <-chan float32, send chan<- complex64, mapF func(float32, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan float32 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrComplex64(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToError(recv <-chan float32, send chan<- error, mapF func(float32, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan float32 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrError(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToFloat32(recv <-chan float32, send chan<- float32, mapF func(float32, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan float32 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrFloat32(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToFloat64(recv <-chan float32, send chan<- float64, mapF func(float32, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan float32 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrFloat64(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToInt(recv <-chan float32, send chan<- int, mapF func(float32, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan float32 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrInt(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToInt16(recv <-chan float32, send chan<- int16, mapF func(float32, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan float32 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrInt16(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToInt32(recv <-chan float32, send chan<- int32, mapF func(float32, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan float32 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrInt32(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToInt64(recv <-chan float32, send chan<- int64, mapF func(float32, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan float32 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrInt64(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToInt8(recv <-chan float32, send chan<- int8, mapF func(float32, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan float32 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrInt8(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToRune(recv <-chan float32, send chan<- rune, mapF func(float32, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan float32 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrRune(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToString(recv <-chan float32, send chan<- string, mapF func(float32, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan float32 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrString(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToUint(recv <-chan float32, send chan<- uint, mapF func(float32, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan float32 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrUint(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToUint16(recv <-chan float32, send chan<- uint16, mapF func(float32, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan float32 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrUint16(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToUint32(recv <-chan float32, send chan<- uint32, mapF func(float32, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan float32 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrUint32(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToUint64(recv <-chan float32, send chan<- uint64, mapF func(float32, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan float32 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrUint64(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToUint8(recv <-chan float32, send chan<- uint8, mapF func(float32, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan float32 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrUint8(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToUintptr(recv <-chan float32, send chan<- uintptr, mapF func(float32, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan float32 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrUintptr(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToInterface(recv <-chan float32, send chan<- interface{}, mapF func(float32, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan float32 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrInterface(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToStruct(recv <-chan float32, send chan<- struct{}, mapF func(float32, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan float32 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrStruct(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat32ToTimeTime(recv <-chan float32, send chan<- time.Time, mapF func(float32, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan float32 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat32OrTimeTime(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToBytes(recv <-chan float64, send chan<- Bytes, mapF func(float64, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan float64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrBytes(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToBool(recv <-chan float64, send chan<- bool, mapF func(float64, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan float64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrBool(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToByte(recv <-chan float64, send chan<- byte, mapF func(float64, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan float64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrByte(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToComplex128(recv <-chan float64, send chan<- complex128, mapF func(float64, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan float64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrComplex128(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToComplex64(recv <-chan float64, send chan<- complex64, mapF func(float64, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan float64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrComplex64(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToError(recv <-chan float64, send chan<- error, mapF func(float64, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan float64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrError(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToFloat32(recv <-chan float64, send chan<- float32, mapF func(float64, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan float64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrFloat32(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToFloat64(recv <-chan float64, send chan<- float64, mapF func(float64, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan float64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrFloat64(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToInt(recv <-chan float64, send chan<- int, mapF func(float64, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan float64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrInt(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToInt16(recv <-chan float64, send chan<- int16, mapF func(float64, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan float64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrInt16(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToInt32(recv <-chan float64, send chan<- int32, mapF func(float64, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan float64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrInt32(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToInt64(recv <-chan float64, send chan<- int64, mapF func(float64, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan float64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrInt64(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToInt8(recv <-chan float64, send chan<- int8, mapF func(float64, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan float64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrInt8(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToRune(recv <-chan float64, send chan<- rune, mapF func(float64, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan float64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrRune(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToString(recv <-chan float64, send chan<- string, mapF func(float64, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan float64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrString(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToUint(recv <-chan float64, send chan<- uint, mapF func(float64, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan float64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrUint(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToUint16(recv <-chan float64, send chan<- uint16, mapF func(float64, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan float64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrUint16(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToUint32(recv <-chan float64, send chan<- uint32, mapF func(float64, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan float64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrUint32(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToUint64(recv <-chan float64, send chan<- uint64, mapF func(float64, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan float64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrUint64(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToUint8(recv <-chan float64, send chan<- uint8, mapF func(float64, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan float64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrUint8(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToUintptr(recv <-chan float64, send chan<- uintptr, mapF func(float64, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan float64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrUintptr(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToInterface(recv <-chan float64, send chan<- interface{}, mapF func(float64, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan float64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrInterface(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToStruct(recv <-chan float64, send chan<- struct{}, mapF func(float64, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan float64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrStruct(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapFloat64ToTimeTime(recv <-chan float64, send chan<- time.Time, mapF func(float64, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan float64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendFloat64OrTimeTime(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToBytes(recv <-chan int, send chan<- Bytes, mapF func(int, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrBytes(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToBool(recv <-chan int, send chan<- bool, mapF func(int, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrBool(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToByte(recv <-chan int, send chan<- byte, mapF func(int, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrByte(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToComplex128(recv <-chan int, send chan<- complex128, mapF func(int, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrComplex128(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToComplex64(recv <-chan int, send chan<- complex64, mapF func(int, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrComplex64(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToError(recv <-chan int, send chan<- error, mapF func(int, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrError(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToFloat32(recv <-chan int, send chan<- float32, mapF func(int, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrFloat32(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToFloat64(recv <-chan int, send chan<- float64, mapF func(int, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrFloat64(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToInt(recv <-chan int, send chan<- int, mapF func(int, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrInt(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToInt16(recv <-chan int, send chan<- int16, mapF func(int, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrInt16(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToInt32(recv <-chan int, send chan<- int32, mapF func(int, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrInt32(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToInt64(recv <-chan int, send chan<- int64, mapF func(int, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrInt64(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToInt8(recv <-chan int, send chan<- int8, mapF func(int, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrInt8(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToRune(recv <-chan int, send chan<- rune, mapF func(int, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrRune(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToString(recv <-chan int, send chan<- string, mapF func(int, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrString(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToUint(recv <-chan int, send chan<- uint, mapF func(int, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrUint(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToUint16(recv <-chan int, send chan<- uint16, mapF func(int, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrUint16(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToUint32(recv <-chan int, send chan<- uint32, mapF func(int, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrUint32(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToUint64(recv <-chan int, send chan<- uint64, mapF func(int, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrUint64(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToUint8(recv <-chan int, send chan<- uint8, mapF func(int, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrUint8(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToUintptr(recv <-chan int, send chan<- uintptr, mapF func(int, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrUintptr(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToInterface(recv <-chan int, send chan<- interface{}, mapF func(int, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrInterface(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToStruct(recv <-chan int, send chan<- struct{}, mapF func(int, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrStruct(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapIntToTimeTime(recv <-chan int, send chan<- time.Time, mapF func(int, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendIntOrTimeTime(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToBytes(recv <-chan int16, send chan<- Bytes, mapF func(int16, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int16 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrBytes(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToBool(recv <-chan int16, send chan<- bool, mapF func(int16, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int16 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrBool(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToByte(recv <-chan int16, send chan<- byte, mapF func(int16, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int16 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrByte(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToComplex128(recv <-chan int16, send chan<- complex128, mapF func(int16, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int16 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrComplex128(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToComplex64(recv <-chan int16, send chan<- complex64, mapF func(int16, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int16 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrComplex64(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToError(recv <-chan int16, send chan<- error, mapF func(int16, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int16 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrError(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToFloat32(recv <-chan int16, send chan<- float32, mapF func(int16, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int16 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrFloat32(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToFloat64(recv <-chan int16, send chan<- float64, mapF func(int16, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int16 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrFloat64(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToInt(recv <-chan int16, send chan<- int, mapF func(int16, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int16 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrInt(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToInt16(recv <-chan int16, send chan<- int16, mapF func(int16, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int16 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrInt16(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToInt32(recv <-chan int16, send chan<- int32, mapF func(int16, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int16 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrInt32(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToInt64(recv <-chan int16, send chan<- int64, mapF func(int16, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int16 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrInt64(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToInt8(recv <-chan int16, send chan<- int8, mapF func(int16, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int16 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrInt8(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToRune(recv <-chan int16, send chan<- rune, mapF func(int16, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int16 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrRune(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToString(recv <-chan int16, send chan<- string, mapF func(int16, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int16 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrString(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToUint(recv <-chan int16, send chan<- uint, mapF func(int16, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int16 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrUint(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToUint16(recv <-chan int16, send chan<- uint16, mapF func(int16, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int16 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrUint16(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToUint32(recv <-chan int16, send chan<- uint32, mapF func(int16, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int16 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrUint32(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToUint64(recv <-chan int16, send chan<- uint64, mapF func(int16, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int16 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrUint64(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToUint8(recv <-chan int16, send chan<- uint8, mapF func(int16, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int16 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrUint8(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToUintptr(recv <-chan int16, send chan<- uintptr, mapF func(int16, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int16 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrUintptr(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToInterface(recv <-chan int16, send chan<- interface{}, mapF func(int16, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int16 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrInterface(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToStruct(recv <-chan int16, send chan<- struct{}, mapF func(int16, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int16 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrStruct(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt16ToTimeTime(recv <-chan int16, send chan<- time.Time, mapF func(int16, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int16 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt16OrTimeTime(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToBytes(recv <-chan int32, send chan<- Bytes, mapF func(int32, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int32 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrBytes(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToBool(recv <-chan int32, send chan<- bool, mapF func(int32, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int32 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrBool(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToByte(recv <-chan int32, send chan<- byte, mapF func(int32, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int32 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrByte(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToComplex128(recv <-chan int32, send chan<- complex128, mapF func(int32, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int32 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrComplex128(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToComplex64(recv <-chan int32, send chan<- complex64, mapF func(int32, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int32 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrComplex64(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToError(recv <-chan int32, send chan<- error, mapF func(int32, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int32 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrError(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToFloat32(recv <-chan int32, send chan<- float32, mapF func(int32, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int32 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrFloat32(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToFloat64(recv <-chan int32, send chan<- float64, mapF func(int32, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int32 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrFloat64(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToInt(recv <-chan int32, send chan<- int, mapF func(int32, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int32 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrInt(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToInt16(recv <-chan int32, send chan<- int16, mapF func(int32, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int32 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrInt16(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToInt32(recv <-chan int32, send chan<- int32, mapF func(int32, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int32 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrInt32(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToInt64(recv <-chan int32, send chan<- int64, mapF func(int32, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int32 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrInt64(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToInt8(recv <-chan int32, send chan<- int8, mapF func(int32, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int32 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrInt8(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToRune(recv <-chan int32, send chan<- rune, mapF func(int32, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int32 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrRune(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToString(recv <-chan int32, send chan<- string, mapF func(int32, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int32 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrString(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToUint(recv <-chan int32, send chan<- uint, mapF func(int32, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int32 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrUint(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToUint16(recv <-chan int32, send chan<- uint16, mapF func(int32, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int32 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrUint16(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToUint32(recv <-chan int32, send chan<- uint32, mapF func(int32, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int32 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrUint32(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToUint64(recv <-chan int32, send chan<- uint64, mapF func(int32, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int32 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrUint64(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToUint8(recv <-chan int32, send chan<- uint8, mapF func(int32, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int32 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrUint8(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToUintptr(recv <-chan int32, send chan<- uintptr, mapF func(int32, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int32 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrUintptr(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToInterface(recv <-chan int32, send chan<- interface{}, mapF func(int32, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int32 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrInterface(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToStruct(recv <-chan int32, send chan<- struct{}, mapF func(int32, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int32 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrStruct(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt32ToTimeTime(recv <-chan int32, send chan<- time.Time, mapF func(int32, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int32 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt32OrTimeTime(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToBytes(recv <-chan int64, send chan<- Bytes, mapF func(int64, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrBytes(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToBool(recv <-chan int64, send chan<- bool, mapF func(int64, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrBool(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToByte(recv <-chan int64, send chan<- byte, mapF func(int64, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrByte(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToComplex128(recv <-chan int64, send chan<- complex128, mapF func(int64, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrComplex128(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToComplex64(recv <-chan int64, send chan<- complex64, mapF func(int64, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrComplex64(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToError(recv <-chan int64, send chan<- error, mapF func(int64, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrError(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToFloat32(recv <-chan int64, send chan<- float32, mapF func(int64, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrFloat32(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToFloat64(recv <-chan int64, send chan<- float64, mapF func(int64, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrFloat64(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToInt(recv <-chan int64, send chan<- int, mapF func(int64, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrInt(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToInt16(recv <-chan int64, send chan<- int16, mapF func(int64, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrInt16(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToInt32(recv <-chan int64, send chan<- int32, mapF func(int64, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrInt32(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToInt64(recv <-chan int64, send chan<- int64, mapF func(int64, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrInt64(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToInt8(recv <-chan int64, send chan<- int8, mapF func(int64, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrInt8(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToRune(recv <-chan int64, send chan<- rune, mapF func(int64, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrRune(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToString(recv <-chan int64, send chan<- string, mapF func(int64, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrString(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToUint(recv <-chan int64, send chan<- uint, mapF func(int64, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrUint(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToUint16(recv <-chan int64, send chan<- uint16, mapF func(int64, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrUint16(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToUint32(recv <-chan int64, send chan<- uint32, mapF func(int64, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrUint32(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToUint64(recv <-chan int64, send chan<- uint64, mapF func(int64, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrUint64(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToUint8(recv <-chan int64, send chan<- uint8, mapF func(int64, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrUint8(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToUintptr(recv <-chan int64, send chan<- uintptr, mapF func(int64, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrUintptr(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToInterface(recv <-chan int64, send chan<- interface{}, mapF func(int64, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrInterface(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToStruct(recv <-chan int64, send chan<- struct{}, mapF func(int64, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrStruct(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt64ToTimeTime(recv <-chan int64, send chan<- time.Time, mapF func(int64, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt64OrTimeTime(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToBytes(recv <-chan int8, send chan<- Bytes, mapF func(int8, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan int8 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrBytes(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToBool(recv <-chan int8, send chan<- bool, mapF func(int8, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan int8 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrBool(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToByte(recv <-chan int8, send chan<- byte, mapF func(int8, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan int8 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrByte(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToComplex128(recv <-chan int8, send chan<- complex128, mapF func(int8, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan int8 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrComplex128(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToComplex64(recv <-chan int8, send chan<- complex64, mapF func(int8, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan int8 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrComplex64(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToError(recv <-chan int8, send chan<- error, mapF func(int8, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan int8 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrError(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToFloat32(recv <-chan int8, send chan<- float32, mapF func(int8, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan int8 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrFloat32(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToFloat64(recv <-chan int8, send chan<- float64, mapF func(int8, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan int8 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrFloat64(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToInt(recv <-chan int8, send chan<- int, mapF func(int8, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan int8 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrInt(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToInt16(recv <-chan int8, send chan<- int16, mapF func(int8, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan int8 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrInt16(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToInt32(recv <-chan int8, send chan<- int32, mapF func(int8, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan int8 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrInt32(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToInt64(recv <-chan int8, send chan<- int64, mapF func(int8, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan int8 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrInt64(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToInt8(recv <-chan int8, send chan<- int8, mapF func(int8, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan int8 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrInt8(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToRune(recv <-chan int8, send chan<- rune, mapF func(int8, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan int8 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrRune(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToString(recv <-chan int8, send chan<- string, mapF func(int8, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan int8 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrString(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToUint(recv <-chan int8, send chan<- uint, mapF func(int8, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan int8 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrUint(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToUint16(recv <-chan int8, send chan<- uint16, mapF func(int8, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan int8 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrUint16(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToUint32(recv <-chan int8, send chan<- uint32, mapF func(int8, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan int8 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrUint32(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToUint64(recv <-chan int8, send chan<- uint64, mapF func(int8, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan int8 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrUint64(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToUint8(recv <-chan int8, send chan<- uint8, mapF func(int8, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan int8 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrUint8(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToUintptr(recv <-chan int8, send chan<- uintptr, mapF func(int8, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan int8 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrUintptr(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToInterface(recv <-chan int8, send chan<- interface{}, mapF func(int8, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan int8 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrInterface(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToStruct(recv <-chan int8, send chan<- struct{}, mapF func(int8, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan int8 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrStruct(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInt8ToTimeTime(recv <-chan int8, send chan<- time.Time, mapF func(int8, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan int8 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInt8OrTimeTime(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToBytes(recv <-chan rune, send chan<- Bytes, mapF func(rune, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan rune = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrBytes(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToBool(recv <-chan rune, send chan<- bool, mapF func(rune, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan rune = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrBool(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToByte(recv <-chan rune, send chan<- byte, mapF func(rune, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan rune = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrByte(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToComplex128(recv <-chan rune, send chan<- complex128, mapF func(rune, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan rune = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrComplex128(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToComplex64(recv <-chan rune, send chan<- complex64, mapF func(rune, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan rune = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrComplex64(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToError(recv <-chan rune, send chan<- error, mapF func(rune, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan rune = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrError(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToFloat32(recv <-chan rune, send chan<- float32, mapF func(rune, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan rune = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrFloat32(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToFloat64(recv <-chan rune, send chan<- float64, mapF func(rune, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan rune = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrFloat64(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToInt(recv <-chan rune, send chan<- int, mapF func(rune, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan rune = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrInt(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToInt16(recv <-chan rune, send chan<- int16, mapF func(rune, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan rune = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrInt16(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToInt32(recv <-chan rune, send chan<- int32, mapF func(rune, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan rune = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrInt32(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToInt64(recv <-chan rune, send chan<- int64, mapF func(rune, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan rune = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrInt64(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToInt8(recv <-chan rune, send chan<- int8, mapF func(rune, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan rune = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrInt8(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToRune(recv <-chan rune, send chan<- rune, mapF func(rune, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan rune = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrRune(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToString(recv <-chan rune, send chan<- string, mapF func(rune, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan rune = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrString(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToUint(recv <-chan rune, send chan<- uint, mapF func(rune, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan rune = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrUint(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToUint16(recv <-chan rune, send chan<- uint16, mapF func(rune, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan rune = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrUint16(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToUint32(recv <-chan rune, send chan<- uint32, mapF func(rune, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan rune = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrUint32(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToUint64(recv <-chan rune, send chan<- uint64, mapF func(rune, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan rune = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrUint64(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToUint8(recv <-chan rune, send chan<- uint8, mapF func(rune, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan rune = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrUint8(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToUintptr(recv <-chan rune, send chan<- uintptr, mapF func(rune, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan rune = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrUintptr(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToInterface(recv <-chan rune, send chan<- interface{}, mapF func(rune, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan rune = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrInterface(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToStruct(recv <-chan rune, send chan<- struct{}, mapF func(rune, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan rune = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrStruct(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapRuneToTimeTime(recv <-chan rune, send chan<- time.Time, mapF func(rune, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan rune = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendRuneOrTimeTime(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToBytes(recv <-chan string, send chan<- Bytes, mapF func(string, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan string = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrBytes(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToBool(recv <-chan string, send chan<- bool, mapF func(string, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan string = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrBool(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToByte(recv <-chan string, send chan<- byte, mapF func(string, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan string = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrByte(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToComplex128(recv <-chan string, send chan<- complex128, mapF func(string, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan string = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrComplex128(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToComplex64(recv <-chan string, send chan<- complex64, mapF func(string, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan string = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrComplex64(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToError(recv <-chan string, send chan<- error, mapF func(string, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan string = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrError(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToFloat32(recv <-chan string, send chan<- float32, mapF func(string, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan string = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrFloat32(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToFloat64(recv <-chan string, send chan<- float64, mapF func(string, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan string = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrFloat64(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToInt(recv <-chan string, send chan<- int, mapF func(string, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan string = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrInt(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToInt16(recv <-chan string, send chan<- int16, mapF func(string, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan string = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrInt16(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToInt32(recv <-chan string, send chan<- int32, mapF func(string, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan string = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrInt32(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToInt64(recv <-chan string, send chan<- int64, mapF func(string, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan string = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrInt64(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToInt8(recv <-chan string, send chan<- int8, mapF func(string, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan string = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrInt8(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToRune(recv <-chan string, send chan<- rune, mapF func(string, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan string = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrRune(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToString(recv <-chan string, send chan<- string, mapF func(string, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan string = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrString(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToUint(recv <-chan string, send chan<- uint, mapF func(string, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan string = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrUint(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToUint16(recv <-chan string, send chan<- uint16, mapF func(string, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan string = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrUint16(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToUint32(recv <-chan string, send chan<- uint32, mapF func(string, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan string = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrUint32(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToUint64(recv <-chan string, send chan<- uint64, mapF func(string, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan string = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrUint64(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToUint8(recv <-chan string, send chan<- uint8, mapF func(string, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan string = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrUint8(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToUintptr(recv <-chan string, send chan<- uintptr, mapF func(string, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan string = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrUintptr(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToInterface(recv <-chan string, send chan<- interface{}, mapF func(string, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan string = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrInterface(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToStruct(recv <-chan string, send chan<- struct{}, mapF func(string, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan string = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrStruct(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStringToTimeTime(recv <-chan string, send chan<- time.Time, mapF func(string, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan string = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStringOrTimeTime(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToBytes(recv <-chan uint, send chan<- Bytes, mapF func(uint, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrBytes(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToBool(recv <-chan uint, send chan<- bool, mapF func(uint, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrBool(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToByte(recv <-chan uint, send chan<- byte, mapF func(uint, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrByte(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToComplex128(recv <-chan uint, send chan<- complex128, mapF func(uint, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrComplex128(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToComplex64(recv <-chan uint, send chan<- complex64, mapF func(uint, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrComplex64(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToError(recv <-chan uint, send chan<- error, mapF func(uint, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrError(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToFloat32(recv <-chan uint, send chan<- float32, mapF func(uint, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrFloat32(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToFloat64(recv <-chan uint, send chan<- float64, mapF func(uint, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrFloat64(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToInt(recv <-chan uint, send chan<- int, mapF func(uint, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrInt(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToInt16(recv <-chan uint, send chan<- int16, mapF func(uint, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrInt16(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToInt32(recv <-chan uint, send chan<- int32, mapF func(uint, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrInt32(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToInt64(recv <-chan uint, send chan<- int64, mapF func(uint, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrInt64(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToInt8(recv <-chan uint, send chan<- int8, mapF func(uint, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrInt8(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToRune(recv <-chan uint, send chan<- rune, mapF func(uint, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrRune(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToString(recv <-chan uint, send chan<- string, mapF func(uint, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrString(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToUint(recv <-chan uint, send chan<- uint, mapF func(uint, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrUint(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToUint16(recv <-chan uint, send chan<- uint16, mapF func(uint, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrUint16(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToUint32(recv <-chan uint, send chan<- uint32, mapF func(uint, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrUint32(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToUint64(recv <-chan uint, send chan<- uint64, mapF func(uint, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrUint64(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToUint8(recv <-chan uint, send chan<- uint8, mapF func(uint, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrUint8(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToUintptr(recv <-chan uint, send chan<- uintptr, mapF func(uint, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrUintptr(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToInterface(recv <-chan uint, send chan<- interface{}, mapF func(uint, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrInterface(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToStruct(recv <-chan uint, send chan<- struct{}, mapF func(uint, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrStruct(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintToTimeTime(recv <-chan uint, send chan<- time.Time, mapF func(uint, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintOrTimeTime(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToBytes(recv <-chan uint16, send chan<- Bytes, mapF func(uint16, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint16 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrBytes(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToBool(recv <-chan uint16, send chan<- bool, mapF func(uint16, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint16 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrBool(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToByte(recv <-chan uint16, send chan<- byte, mapF func(uint16, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint16 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrByte(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToComplex128(recv <-chan uint16, send chan<- complex128, mapF func(uint16, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint16 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrComplex128(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToComplex64(recv <-chan uint16, send chan<- complex64, mapF func(uint16, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint16 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrComplex64(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToError(recv <-chan uint16, send chan<- error, mapF func(uint16, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint16 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrError(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToFloat32(recv <-chan uint16, send chan<- float32, mapF func(uint16, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint16 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrFloat32(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToFloat64(recv <-chan uint16, send chan<- float64, mapF func(uint16, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint16 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrFloat64(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToInt(recv <-chan uint16, send chan<- int, mapF func(uint16, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint16 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrInt(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToInt16(recv <-chan uint16, send chan<- int16, mapF func(uint16, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint16 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrInt16(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToInt32(recv <-chan uint16, send chan<- int32, mapF func(uint16, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint16 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrInt32(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToInt64(recv <-chan uint16, send chan<- int64, mapF func(uint16, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint16 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrInt64(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToInt8(recv <-chan uint16, send chan<- int8, mapF func(uint16, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint16 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrInt8(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToRune(recv <-chan uint16, send chan<- rune, mapF func(uint16, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint16 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrRune(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToString(recv <-chan uint16, send chan<- string, mapF func(uint16, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint16 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrString(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToUint(recv <-chan uint16, send chan<- uint, mapF func(uint16, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint16 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrUint(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToUint16(recv <-chan uint16, send chan<- uint16, mapF func(uint16, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint16 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrUint16(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToUint32(recv <-chan uint16, send chan<- uint32, mapF func(uint16, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint16 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrUint32(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToUint64(recv <-chan uint16, send chan<- uint64, mapF func(uint16, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint16 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrUint64(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToUint8(recv <-chan uint16, send chan<- uint8, mapF func(uint16, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint16 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrUint8(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToUintptr(recv <-chan uint16, send chan<- uintptr, mapF func(uint16, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint16 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrUintptr(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToInterface(recv <-chan uint16, send chan<- interface{}, mapF func(uint16, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint16 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrInterface(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToStruct(recv <-chan uint16, send chan<- struct{}, mapF func(uint16, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint16 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrStruct(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint16ToTimeTime(recv <-chan uint16, send chan<- time.Time, mapF func(uint16, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint16 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint16OrTimeTime(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToBytes(recv <-chan uint32, send chan<- Bytes, mapF func(uint32, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint32 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrBytes(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToBool(recv <-chan uint32, send chan<- bool, mapF func(uint32, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint32 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrBool(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToByte(recv <-chan uint32, send chan<- byte, mapF func(uint32, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint32 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrByte(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToComplex128(recv <-chan uint32, send chan<- complex128, mapF func(uint32, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint32 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrComplex128(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToComplex64(recv <-chan uint32, send chan<- complex64, mapF func(uint32, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint32 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrComplex64(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToError(recv <-chan uint32, send chan<- error, mapF func(uint32, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint32 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrError(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToFloat32(recv <-chan uint32, send chan<- float32, mapF func(uint32, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint32 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrFloat32(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToFloat64(recv <-chan uint32, send chan<- float64, mapF func(uint32, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint32 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrFloat64(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToInt(recv <-chan uint32, send chan<- int, mapF func(uint32, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint32 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrInt(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToInt16(recv <-chan uint32, send chan<- int16, mapF func(uint32, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint32 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrInt16(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToInt32(recv <-chan uint32, send chan<- int32, mapF func(uint32, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint32 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrInt32(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToInt64(recv <-chan uint32, send chan<- int64, mapF func(uint32, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint32 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrInt64(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToInt8(recv <-chan uint32, send chan<- int8, mapF func(uint32, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint32 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrInt8(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToRune(recv <-chan uint32, send chan<- rune, mapF func(uint32, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint32 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrRune(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToString(recv <-chan uint32, send chan<- string, mapF func(uint32, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint32 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrString(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToUint(recv <-chan uint32, send chan<- uint, mapF func(uint32, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint32 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrUint(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToUint16(recv <-chan uint32, send chan<- uint16, mapF func(uint32, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint32 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrUint16(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToUint32(recv <-chan uint32, send chan<- uint32, mapF func(uint32, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint32 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrUint32(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToUint64(recv <-chan uint32, send chan<- uint64, mapF func(uint32, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint32 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrUint64(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToUint8(recv <-chan uint32, send chan<- uint8, mapF func(uint32, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint32 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrUint8(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToUintptr(recv <-chan uint32, send chan<- uintptr, mapF func(uint32, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint32 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrUintptr(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToInterface(recv <-chan uint32, send chan<- interface{}, mapF func(uint32, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint32 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrInterface(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToStruct(recv <-chan uint32, send chan<- struct{}, mapF func(uint32, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint32 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrStruct(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint32ToTimeTime(recv <-chan uint32, send chan<- time.Time, mapF func(uint32, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint32 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint32OrTimeTime(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToBytes(recv <-chan uint64, send chan<- Bytes, mapF func(uint64, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint64 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrBytes(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToBool(recv <-chan uint64, send chan<- bool, mapF func(uint64, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint64 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrBool(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToByte(recv <-chan uint64, send chan<- byte, mapF func(uint64, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint64 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrByte(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToComplex128(recv <-chan uint64, send chan<- complex128, mapF func(uint64, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint64 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrComplex128(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToComplex64(recv <-chan uint64, send chan<- complex64, mapF func(uint64, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint64 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrComplex64(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToError(recv <-chan uint64, send chan<- error, mapF func(uint64, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint64 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrError(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToFloat32(recv <-chan uint64, send chan<- float32, mapF func(uint64, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint64 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrFloat32(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToFloat64(recv <-chan uint64, send chan<- float64, mapF func(uint64, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint64 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrFloat64(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToInt(recv <-chan uint64, send chan<- int, mapF func(uint64, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint64 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrInt(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToInt16(recv <-chan uint64, send chan<- int16, mapF func(uint64, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint64 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrInt16(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToInt32(recv <-chan uint64, send chan<- int32, mapF func(uint64, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint64 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrInt32(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToInt64(recv <-chan uint64, send chan<- int64, mapF func(uint64, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint64 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrInt64(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToInt8(recv <-chan uint64, send chan<- int8, mapF func(uint64, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint64 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrInt8(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToRune(recv <-chan uint64, send chan<- rune, mapF func(uint64, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint64 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrRune(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToString(recv <-chan uint64, send chan<- string, mapF func(uint64, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint64 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrString(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToUint(recv <-chan uint64, send chan<- uint, mapF func(uint64, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint64 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrUint(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToUint16(recv <-chan uint64, send chan<- uint16, mapF func(uint64, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint64 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrUint16(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToUint32(recv <-chan uint64, send chan<- uint32, mapF func(uint64, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint64 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrUint32(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToUint64(recv <-chan uint64, send chan<- uint64, mapF func(uint64, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint64 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrUint64(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToUint8(recv <-chan uint64, send chan<- uint8, mapF func(uint64, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint64 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrUint8(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToUintptr(recv <-chan uint64, send chan<- uintptr, mapF func(uint64, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint64 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrUintptr(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToInterface(recv <-chan uint64, send chan<- interface{}, mapF func(uint64, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint64 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrInterface(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToStruct(recv <-chan uint64, send chan<- struct{}, mapF func(uint64, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint64 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrStruct(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint64ToTimeTime(recv <-chan uint64, send chan<- time.Time, mapF func(uint64, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint64 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint64OrTimeTime(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToBytes(recv <-chan uint8, send chan<- Bytes, mapF func(uint8, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uint8 = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrBytes(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToBool(recv <-chan uint8, send chan<- bool, mapF func(uint8, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uint8 = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrBool(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToByte(recv <-chan uint8, send chan<- byte, mapF func(uint8, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uint8 = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrByte(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToComplex128(recv <-chan uint8, send chan<- complex128, mapF func(uint8, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uint8 = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrComplex128(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToComplex64(recv <-chan uint8, send chan<- complex64, mapF func(uint8, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uint8 = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrComplex64(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToError(recv <-chan uint8, send chan<- error, mapF func(uint8, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uint8 = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrError(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToFloat32(recv <-chan uint8, send chan<- float32, mapF func(uint8, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uint8 = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrFloat32(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToFloat64(recv <-chan uint8, send chan<- float64, mapF func(uint8, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uint8 = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrFloat64(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToInt(recv <-chan uint8, send chan<- int, mapF func(uint8, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uint8 = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrInt(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToInt16(recv <-chan uint8, send chan<- int16, mapF func(uint8, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uint8 = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrInt16(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToInt32(recv <-chan uint8, send chan<- int32, mapF func(uint8, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uint8 = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrInt32(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToInt64(recv <-chan uint8, send chan<- int64, mapF func(uint8, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uint8 = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrInt64(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToInt8(recv <-chan uint8, send chan<- int8, mapF func(uint8, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uint8 = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrInt8(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToRune(recv <-chan uint8, send chan<- rune, mapF func(uint8, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uint8 = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrRune(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToString(recv <-chan uint8, send chan<- string, mapF func(uint8, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uint8 = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrString(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToUint(recv <-chan uint8, send chan<- uint, mapF func(uint8, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uint8 = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrUint(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToUint16(recv <-chan uint8, send chan<- uint16, mapF func(uint8, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uint8 = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrUint16(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToUint32(recv <-chan uint8, send chan<- uint32, mapF func(uint8, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uint8 = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrUint32(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToUint64(recv <-chan uint8, send chan<- uint64, mapF func(uint8, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uint8 = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrUint64(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToUint8(recv <-chan uint8, send chan<- uint8, mapF func(uint8, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uint8 = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrUint8(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToUintptr(recv <-chan uint8, send chan<- uintptr, mapF func(uint8, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uint8 = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrUintptr(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToInterface(recv <-chan uint8, send chan<- interface{}, mapF func(uint8, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uint8 = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrInterface(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToStruct(recv <-chan uint8, send chan<- struct{}, mapF func(uint8, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uint8 = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrStruct(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUint8ToTimeTime(recv <-chan uint8, send chan<- time.Time, mapF func(uint8, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uint8 = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUint8OrTimeTime(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToBytes(recv <-chan uintptr, send chan<- Bytes, mapF func(uintptr, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan uintptr = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrBytes(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToBool(recv <-chan uintptr, send chan<- bool, mapF func(uintptr, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan uintptr = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrBool(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToByte(recv <-chan uintptr, send chan<- byte, mapF func(uintptr, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan uintptr = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrByte(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToComplex128(recv <-chan uintptr, send chan<- complex128, mapF func(uintptr, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan uintptr = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrComplex128(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToComplex64(recv <-chan uintptr, send chan<- complex64, mapF func(uintptr, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan uintptr = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrComplex64(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToError(recv <-chan uintptr, send chan<- error, mapF func(uintptr, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan uintptr = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrError(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToFloat32(recv <-chan uintptr, send chan<- float32, mapF func(uintptr, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan uintptr = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrFloat32(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToFloat64(recv <-chan uintptr, send chan<- float64, mapF func(uintptr, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan uintptr = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrFloat64(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToInt(recv <-chan uintptr, send chan<- int, mapF func(uintptr, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan uintptr = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrInt(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToInt16(recv <-chan uintptr, send chan<- int16, mapF func(uintptr, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan uintptr = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrInt16(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToInt32(recv <-chan uintptr, send chan<- int32, mapF func(uintptr, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan uintptr = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrInt32(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToInt64(recv <-chan uintptr, send chan<- int64, mapF func(uintptr, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan uintptr = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrInt64(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToInt8(recv <-chan uintptr, send chan<- int8, mapF func(uintptr, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan uintptr = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrInt8(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToRune(recv <-chan uintptr, send chan<- rune, mapF func(uintptr, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan uintptr = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrRune(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToString(recv <-chan uintptr, send chan<- string, mapF func(uintptr, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan uintptr = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrString(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToUint(recv <-chan uintptr, send chan<- uint, mapF func(uintptr, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan uintptr = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrUint(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToUint16(recv <-chan uintptr, send chan<- uint16, mapF func(uintptr, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan uintptr = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrUint16(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToUint32(recv <-chan uintptr, send chan<- uint32, mapF func(uintptr, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan uintptr = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrUint32(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToUint64(recv <-chan uintptr, send chan<- uint64, mapF func(uintptr, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan uintptr = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrUint64(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToUint8(recv <-chan uintptr, send chan<- uint8, mapF func(uintptr, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan uintptr = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrUint8(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToUintptr(recv <-chan uintptr, send chan<- uintptr, mapF func(uintptr, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan uintptr = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrUintptr(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToInterface(recv <-chan uintptr, send chan<- interface{}, mapF func(uintptr, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan uintptr = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrInterface(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToStruct(recv <-chan uintptr, send chan<- struct{}, mapF func(uintptr, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan uintptr = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrStruct(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapUintptrToTimeTime(recv <-chan uintptr, send chan<- time.Time, mapF func(uintptr, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan uintptr = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendUintptrOrTimeTime(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToBytes(recv <-chan interface{}, send chan<- Bytes, mapF func(interface{}, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan interface{} = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrBytes(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToBool(recv <-chan interface{}, send chan<- bool, mapF func(interface{}, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan interface{} = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrBool(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToByte(recv <-chan interface{}, send chan<- byte, mapF func(interface{}, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan interface{} = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrByte(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToComplex128(recv <-chan interface{}, send chan<- complex128, mapF func(interface{}, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan interface{} = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrComplex128(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToComplex64(recv <-chan interface{}, send chan<- complex64, mapF func(interface{}, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan interface{} = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrComplex64(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToError(recv <-chan interface{}, send chan<- error, mapF func(interface{}, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan interface{} = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrError(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToFloat32(recv <-chan interface{}, send chan<- float32, mapF func(interface{}, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan interface{} = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrFloat32(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToFloat64(recv <-chan interface{}, send chan<- float64, mapF func(interface{}, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan interface{} = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrFloat64(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToInt(recv <-chan interface{}, send chan<- int, mapF func(interface{}, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan interface{} = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrInt(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToInt16(recv <-chan interface{}, send chan<- int16, mapF func(interface{}, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan interface{} = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrInt16(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToInt32(recv <-chan interface{}, send chan<- int32, mapF func(interface{}, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan interface{} = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrInt32(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToInt64(recv <-chan interface{}, send chan<- int64, mapF func(interface{}, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan interface{} = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrInt64(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToInt8(recv <-chan interface{}, send chan<- int8, mapF func(interface{}, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan interface{} = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrInt8(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToRune(recv <-chan interface{}, send chan<- rune, mapF func(interface{}, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan interface{} = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrRune(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToString(recv <-chan interface{}, send chan<- string, mapF func(interface{}, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan interface{} = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrString(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToUint(recv <-chan interface{}, send chan<- uint, mapF func(interface{}, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan interface{} = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrUint(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToUint16(recv <-chan interface{}, send chan<- uint16, mapF func(interface{}, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan interface{} = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrUint16(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToUint32(recv <-chan interface{}, send chan<- uint32, mapF func(interface{}, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan interface{} = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrUint32(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToUint64(recv <-chan interface{}, send chan<- uint64, mapF func(interface{}, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan interface{} = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrUint64(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToUint8(recv <-chan interface{}, send chan<- uint8, mapF func(interface{}, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan interface{} = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrUint8(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToUintptr(recv <-chan interface{}, send chan<- uintptr, mapF func(interface{}, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan interface{} = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrUintptr(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToInterface(recv <-chan interface{}, send chan<- interface{}, mapF func(interface{}, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan interface{} = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrInterface(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToStruct(recv <-chan interface{}, send chan<- struct{}, mapF func(interface{}, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan interface{} = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrStruct(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapInterfaceToTimeTime(recv <-chan interface{}, send chan<- time.Time, mapF func(interface{}, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan interface{} = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendInterfaceOrTimeTime(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToBytes(recv <-chan struct{}, send chan<- Bytes, mapF func(struct{}, bool) (Bytes, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- Bytes
		var recv_ch <-chan struct{} = recv
		var to_send Bytes

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrBytes(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan Bytes, elseF func(v Bytes, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToBool(recv <-chan struct{}, send chan<- bool, mapF func(struct{}, bool) (bool, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- bool
		var recv_ch <-chan struct{} = recv
		var to_send bool

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrBool(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan bool, elseF func(v bool, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToByte(recv <-chan struct{}, send chan<- byte, mapF func(struct{}, bool) (byte, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- byte
		var recv_ch <-chan struct{} = recv
		var to_send byte

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrByte(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan byte, elseF func(v byte, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToComplex128(recv <-chan struct{}, send chan<- complex128, mapF func(struct{}, bool) (complex128, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex128
		var recv_ch <-chan struct{} = recv
		var to_send complex128

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrComplex128(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan complex128, elseF func(v complex128, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToComplex64(recv <-chan struct{}, send chan<- complex64, mapF func(struct{}, bool) (complex64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- complex64
		var recv_ch <-chan struct{} = recv
		var to_send complex64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrComplex64(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan complex64, elseF func(v complex64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToError(recv <-chan struct{}, send chan<- error, mapF func(struct{}, bool) (error, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- error
		var recv_ch <-chan struct{} = recv
		var to_send error

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrError(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan error, elseF func(v error, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToFloat32(recv <-chan struct{}, send chan<- float32, mapF func(struct{}, bool) (float32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float32
		var recv_ch <-chan struct{} = recv
		var to_send float32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrFloat32(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan float32, elseF func(v float32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToFloat64(recv <-chan struct{}, send chan<- float64, mapF func(struct{}, bool) (float64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- float64
		var recv_ch <-chan struct{} = recv
		var to_send float64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrFloat64(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan float64, elseF func(v float64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToInt(recv <-chan struct{}, send chan<- int, mapF func(struct{}, bool) (int, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int
		var recv_ch <-chan struct{} = recv
		var to_send int

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrInt(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int, elseF func(v int, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToInt16(recv <-chan struct{}, send chan<- int16, mapF func(struct{}, bool) (int16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int16
		var recv_ch <-chan struct{} = recv
		var to_send int16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrInt16(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int16, elseF func(v int16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToInt32(recv <-chan struct{}, send chan<- int32, mapF func(struct{}, bool) (int32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int32
		var recv_ch <-chan struct{} = recv
		var to_send int32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrInt32(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int32, elseF func(v int32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToInt64(recv <-chan struct{}, send chan<- int64, mapF func(struct{}, bool) (int64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int64
		var recv_ch <-chan struct{} = recv
		var to_send int64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrInt64(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int64, elseF func(v int64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToInt8(recv <-chan struct{}, send chan<- int8, mapF func(struct{}, bool) (int8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- int8
		var recv_ch <-chan struct{} = recv
		var to_send int8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrInt8(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan int8, elseF func(v int8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToRune(recv <-chan struct{}, send chan<- rune, mapF func(struct{}, bool) (rune, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- rune
		var recv_ch <-chan struct{} = recv
		var to_send rune

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrRune(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan rune, elseF func(v rune, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToString(recv <-chan struct{}, send chan<- string, mapF func(struct{}, bool) (string, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- string
		var recv_ch <-chan struct{} = recv
		var to_send string

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrString(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan string, elseF func(v string, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToUint(recv <-chan struct{}, send chan<- uint, mapF func(struct{}, bool) (uint, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint
		var recv_ch <-chan struct{} = recv
		var to_send uint

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrUint(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint, elseF func(v uint, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToUint16(recv <-chan struct{}, send chan<- uint16, mapF func(struct{}, bool) (uint16, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint16
		var recv_ch <-chan struct{} = recv
		var to_send uint16

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrUint16(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint16, elseF func(v uint16, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToUint32(recv <-chan struct{}, send chan<- uint32, mapF func(struct{}, bool) (uint32, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint32
		var recv_ch <-chan struct{} = recv
		var to_send uint32

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrUint32(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint32, elseF func(v uint32, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToUint64(recv <-chan struct{}, send chan<- uint64, mapF func(struct{}, bool) (uint64, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint64
		var recv_ch <-chan struct{} = recv
		var to_send uint64

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrUint64(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint64, elseF func(v uint64, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToUint8(recv <-chan struct{}, send chan<- uint8, mapF func(struct{}, bool) (uint8, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uint8
		var recv_ch <-chan struct{} = recv
		var to_send uint8

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrUint8(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uint8, elseF func(v uint8, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToUintptr(recv <-chan struct{}, send chan<- uintptr, mapF func(struct{}, bool) (uintptr, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- uintptr
		var recv_ch <-chan struct{} = recv
		var to_send uintptr

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrUintptr(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan uintptr, elseF func(v uintptr, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToInterface(recv <-chan struct{}, send chan<- interface{}, mapF func(struct{}, bool) (interface{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- interface{}
		var recv_ch <-chan struct{} = recv
		var to_send interface{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrInterface(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan interface{}, elseF func(v interface{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToStruct(recv <-chan struct{}, send chan<- struct{}, mapF func(struct{}, bool) (struct{}, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- struct{}
		var recv_ch <-chan struct{} = recv
		var to_send struct{}

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrStruct(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan struct{}, elseF func(v struct{}, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) MapStructToTimeTime(recv <-chan struct{}, send chan<- time.Time, mapF func(struct{}, bool) (time.Time, error), onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var err error
		var send_ch chan<- time.Time
		var recv_ch <-chan struct{} = recv
		var to_send time.Time

	loop:
		for {
			select {
			case d, ok := <-recv_ch:
				to_send, err = mapF(d, ok)
				switch err {
				case core.ErrSkipMap:
					continue
				case nil:
					recv_ch = nil
					send_ch = send
				default:
					if onEvent != nil {
						switch ok {
						case false:
							onEvent(core.CASE_CLOSED)
						default:
							onEvent(core.CASE_STOP)
						}
					}
					break loop
				}

			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv

			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseSendStructOrTimeTime(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan time.Time, elseF func(v time.Time, ok bool)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case v, ok := <-elseCh:
			if elseF != nil {
				elseF(v, ok)
			}
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package generated

import "github.com/mark-ahn/chans/v1/core"

func (__ *Chain) CaseRecvBytes(ch <-chan Bytes, f func(v Bytes, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendBytes(ch chan<- Bytes, v Bytes, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectBytes(recv <-chan Bytes, send chan<- Bytes, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan Bytes = recv
		var send_ch chan<- Bytes
		var to_send Bytes

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvBool(ch <-chan bool, f func(v bool, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendBool(ch chan<- bool, v bool, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectBool(recv <-chan bool, send chan<- bool, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan bool = recv
		var send_ch chan<- bool
		var to_send bool

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvByte(ch <-chan byte, f func(v byte, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendByte(ch chan<- byte, v byte, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectByte(recv <-chan byte, send chan<- byte, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan byte = recv
		var send_ch chan<- byte
		var to_send byte

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvComplex128(ch <-chan complex128, f func(v complex128, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendComplex128(ch chan<- complex128, v complex128, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectComplex128(recv <-chan complex128, send chan<- complex128, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan complex128 = recv
		var send_ch chan<- complex128
		var to_send complex128

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvComplex64(ch <-chan complex64, f func(v complex64, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendComplex64(ch chan<- complex64, v complex64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectComplex64(recv <-chan complex64, send chan<- complex64, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan complex64 = recv
		var send_ch chan<- complex64
		var to_send complex64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvError(ch <-chan error, f func(v error, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendError(ch chan<- error, v error, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectError(recv <-chan error, send chan<- error, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan error = recv
		var send_ch chan<- error
		var to_send error

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvFloat32(ch <-chan float32, f func(v float32, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendFloat32(ch chan<- float32, v float32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectFloat32(recv <-chan float32, send chan<- float32, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan float32 = recv
		var send_ch chan<- float32
		var to_send float32

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvFloat64(ch <-chan float64, f func(v float64, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendFloat64(ch chan<- float64, v float64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectFloat64(recv <-chan float64, send chan<- float64, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan float64 = recv
		var send_ch chan<- float64
		var to_send float64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvInt(ch <-chan int, f func(v int, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendInt(ch chan<- int, v int, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectInt(recv <-chan int, send chan<- int, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan int = recv
		var send_ch chan<- int
		var to_send int

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvInt16(ch <-chan int16, f func(v int16, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendInt16(ch chan<- int16, v int16, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectInt16(recv <-chan int16, send chan<- int16, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan int16 = recv
		var send_ch chan<- int16
		var to_send int16

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvInt32(ch <-chan int32, f func(v int32, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendInt32(ch chan<- int32, v int32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectInt32(recv <-chan int32, send chan<- int32, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan int32 = recv
		var send_ch chan<- int32
		var to_send int32

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvInt64(ch <-chan int64, f func(v int64, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendInt64(ch chan<- int64, v int64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectInt64(recv <-chan int64, send chan<- int64, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan int64 = recv
		var send_ch chan<- int64
		var to_send int64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvInt8(ch <-chan int8, f func(v int8, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendInt8(ch chan<- int8, v int8, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectInt8(recv <-chan int8, send chan<- int8, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan int8 = recv
		var send_ch chan<- int8
		var to_send int8

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvRune(ch <-chan rune, f func(v rune, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendRune(ch chan<- rune, v rune, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectRune(recv <-chan rune, send chan<- rune, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan rune = recv
		var send_ch chan<- rune
		var to_send rune

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvString(ch <-chan string, f func(v string, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendString(ch chan<- string, v string, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectString(recv <-chan string, send chan<- string, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan string = recv
		var send_ch chan<- string
		var to_send string

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvUint(ch <-chan uint, f func(v uint, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendUint(ch chan<- uint, v uint, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectUint(recv <-chan uint, send chan<- uint, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan uint = recv
		var send_ch chan<- uint
		var to_send uint

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvUint16(ch <-chan uint16, f func(v uint16, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendUint16(ch chan<- uint16, v uint16, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectUint16(recv <-chan uint16, send chan<- uint16, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan uint16 = recv
		var send_ch chan<- uint16
		var to_send uint16

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvUint32(ch <-chan uint32, f func(v uint32, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendUint32(ch chan<- uint32, v uint32, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectUint32(recv <-chan uint32, send chan<- uint32, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan uint32 = recv
		var send_ch chan<- uint32
		var to_send uint32

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvUint64(ch <-chan uint64, f func(v uint64, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendUint64(ch chan<- uint64, v uint64, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectUint64(recv <-chan uint64, send chan<- uint64, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan uint64 = recv
		var send_ch chan<- uint64
		var to_send uint64

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvUint8(ch <-chan uint8, f func(v uint8, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendUint8(ch chan<- uint8, v uint8, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectUint8(recv <-chan uint8, send chan<- uint8, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan uint8 = recv
		var send_ch chan<- uint8
		var to_send uint8

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvUintptr(ch <-chan uintptr, f func(v uintptr, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendUintptr(ch chan<- uintptr, v uintptr, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectUintptr(recv <-chan uintptr, send chan<- uintptr, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan uintptr = recv
		var send_ch chan<- uintptr
		var to_send uintptr

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvInterface(ch <-chan interface{}, f func(v interface{}, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendInterface(ch chan<- interface{}, v interface{}, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectInterface(recv <-chan interface{}, send chan<- interface{}, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan interface{} = recv
		var send_ch chan<- interface{}
		var to_send interface{}

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}

func (__ *Chain) CaseRecvStruct(ch <-chan struct{}, f func(v struct{}, ok bool) core.CaseControl, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		for {
			select {
			case v, ok := <-ch:
				res := f(v, ok)
				switch {
				case ok && res == core.CASE_OK:
					continue
				default:
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}

	}()
	return __
}

func (__ *Chain) CaseSendStruct(ch chan<- struct{}, v struct{}, onEvent func(sent core.CaseResult), elseCh <-chan struct{}) *Chain {
	__.AddThread(1)
	go func() {
		defer __.DoneThread()

	loop:
		select {
		case ch <- v:
			if onEvent != nil {
				onEvent(core.CASE_SENT)
			}
		case <-elseCh:
			if onEvent != nil {
				onEvent(core.CASE_ELSE)
			}
		case <-__.Context().Done():
			if onEvent != nil {
				onEvent(core.CASE_CANCEL)
			}
			break loop
		}
	}()
	return __
}

func (__ *Chain) ConnectStruct(recv <-chan struct{}, send chan<- struct{}, onEvent func(core.CaseResult)) *Chain {
	__.AddThread(1)
	go func() {
		__.DoneThread()

		var ok bool
		var recv_ch <-chan struct{} = recv
		var send_ch chan<- struct{}
		var to_send struct{}

	loop:
		for {
			select {
			case to_send, ok = <-recv_ch:
				if !ok {
					if onEvent != nil {
						onEvent(core.CASE_CLOSED)
					}
					break loop
				}
				recv_ch = nil
				send_ch = send
			case send_ch <- to_send:
				send_ch = nil
				recv_ch = recv
			case <-__.Context().Done():
				if onEvent != nil {
					onEvent(core.CASE_CANCEL)
				}
				break loop
			}
		}
	}()

	return __
}
